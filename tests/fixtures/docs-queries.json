[
  {
    "query": "CREATE TABLE prices (\n    ts TIMESTAMP,\n    ticker SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY WAL\nDEDUP UPSERT KEYS(ts, ticker)"
  },
  {
    "query": "INSERT INTO prices VALUES ('2026-01-15T10:00:00', 'AAPL', 185.50)"
  },
  {
    "query": "INSERT INTO prices VALUES ('2026-01-15T10:00:00', 'AAPL', 186.00)"
  },
  {
    "query": "SELECT * FROM prices"
  },
  {
    "query": "ALTER TABLE prices DEDUP ENABLE UPSERT KEYS(ts, ticker)"
  },
  {
    "query": "ALTER TABLE prices DEDUP DISABLE"
  },
  {
    "query": "ALTER TABLE prices DEDUP ENABLE UPSERT KEYS(ts, ticker, exchange)"
  },
  {
    "query": "SELECT dedup FROM tables() WHERE table_name = 'prices'"
  },
  {
    "query": "SELECT \"column\", upsertKey FROM table_columns('prices')"
  },
  {
    "query": "CREATE TABLE my_table(symb SYMBOL, price DOUBLE, ts TIMESTAMP),\n  INDEX (symb) timestamp(ts)"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades\nWHERE timestamp IN '2024-01-20'"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp IN '2024-01-20'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp BETWEEN '2024-01-20T00:00:00.000000Z'\n                    AND '2024-01-20T23:59:59.999999Z'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp >= '2024-01-20T00:00:00.000000Z'\n  AND timestamp <= '2024-01-20T23:59:59.999999Z'"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades\nWHERE timestamp IN '2024-01-[15,16,17]'"
  },
  {
    "query": "CREATE TABLE trades_new (\n    ts TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO trades_new SELECT * FROM trades_old ORDER BY ts"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades_nodts TIMESTAMP(ts)\nWHERE ts IN '2024-01-20'"
  },
  {
    "query": "SELECT * FROM (SELECT * FROM unordered_table ORDER BY ts) TIMESTAMP(ts)\nWHERE ts IN '2024-01-20'"
  },
  {
    "query": "SELECT * FROM (SELECT * FROM trades WHERE symbol = 'BTC-USD')\nWHERE timestamp IN '2024-01-20'"
  },
  {
    "query": "SELECT * FROM (SELECT * FROM trades WHERE symbol = 'BTC-USD') TIMESTAMP(timestamp)\nWHERE timestamp IN '2024-01-20'"
  },
  {
    "query": "SELECT count(), max(bid_price) FROM core_price\nWHERE\ntimestamp in today() AND bid_price > 1 AND Symbol = 'EURUSD'"
  },
  {
    "query": "-- sub-queries\nEXPLAIN SELECT symbol, count(), max(bid_price) FROM core_price\nWHERE timestamp in today() AND bid_price > 1"
  },
  {
    "query": "SELECT reload_config()"
  },
  {
    "query": "SELECT * from _query_trace"
  },
  {
    "query": "SELECT\n    query_text\nFROM _query_trace\nWHERE execution_micros > 100_000\nORDER BY execution_micros DESC"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp IN today()\nLATEST ON timestamp PARTITION BY symbol, side"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp IN '2025'"
  },
  {
    "query": "SELECT timestamp, symbol, sum(price) FROM trades\nWHERE timestamp in today()\nSAMPLE BY 1h"
  },
  {
    "query": "trades",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM trades"
  },
  {
    "query": "SELECT symbol, side, sum(price) FROM trades\nWHERE timestamp IN today()\nGROUP BY symbol, side"
  },
  {
    "query": "SELECT symbol, side, sum(price) FROM trades\nWHERE timestamp IN today()"
  },
  {
    "query": "(\n  SELECT symbol, side, sum(price) as total_price\n  FROM trades WHERE timestamp IN today()\n)\nWHERE total_price > 10_000_000",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT /*+ asof_dense(orders md) */\n    orders.timestamp, orders.symbol, orders.price\nFROM orders\nASOF JOIN (md) ON (symbol)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT /*+ asof_linear(orders md) */\n  orders.ts, orders.price, md.md_ts, md.bid, md.ask\nFROM orders\nASOF JOIN (\n  SELECT ts as md_ts, bid, ask FROM market_data\n  WHERE state = 'INVALID' -- Highly selective filter\n) md"
  },
  {
    "query": "SELECT /*+ asof_memoized(orders md) */\n    orders.timestamp, orders.symbol, orders.price\nFROM orders\nASOF JOIN (md) ON (symbol)",
    "skipAutocomplete": true
  },
  {
    "query": "EXPLAIN SELECT  *\nFROM core_price\nASOF JOIN market_data\nON symbol\nWHERE bids[1,1]=107.03 -- Highly selective filter"
  },
  {
    "query": "EXPLAIN SELECT /*+ asof_linear(core_price market_data) */\n  *\nFROM core_price\nASOF JOIN market_data\nON symbol\nWHERE bids[1,1]=107.03 -- Highly selective filter"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2024-01-[01..31]T09:30@America/New_York#workday;6h30m'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '[$today-5bd..$today-1bd]T09:30;1h'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp > '2024-01-15' AND timestamp < '2024-01-16'"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades WHERE timestamp IN '2024-01-15'"
  },
  {
    "query": "CREATE TABLE trades (\n    ts TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE,\n    amount DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "SELECT * FROM (\n    SELECT ts, symbol, price FROM trades\n    UNION ALL\n    SELECT ts, symbol, price FROM trades_archive\n    ORDER BY ts\n) TIMESTAMP(ts)"
  },
  {
    "query": "CREATE TABLE trades_new (\n    event_time TIMESTAMP,  -- new designated timestamp\n    ingest_time TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE\n) TIMESTAMP(event_time) PARTITION BY DAY"
  },
  {
    "query": "-- 2. Copy data (will be reordered by new designated timestamp)\nINSERT INTO trades_new\nSELECT event_time, ingest_time, symbol, price\nFROM trades\nORDER BY event_time"
  },
  {
    "query": "-- 3. Swap tables\nDROP TABLE trades"
  },
  {
    "query": "RENAME TABLE trades_new TO trades"
  },
  {
    "query": "-- This will fail:\nUPDATE trades SET ts = '2024-01-15T12:00:00Z' WHERE symbol = 'BTC-USD'"
  },
  {
    "query": "CREATE TABLE trades_temp AS (\n    SELECT * FROM trades\n    WHERE ts IN '2024-01-15'\n)"
  },
  {
    "query": "-- 2. Drop the partition from the source table\nALTER TABLE trades DROP PARTITION LIST '2024-01-15'"
  },
  {
    "query": "-- 3. Update timestamps freely in the temp table (no designated timestamp)\nUPDATE trades_temp\nSET ts = dateadd('h', 1, ts)\nWHERE symbol = 'BTC-USD'"
  },
  {
    "query": "-- 4. Re-insert into main table (data will be sorted automatically)\nINSERT INTO trades SELECT * FROM trades_temp"
  },
  {
    "query": "-- 5. Clean up\nDROP TABLE trades_temp"
  },
  {
    "query": "CREATE TABLE orders (\n    exchange_ts TIMESTAMP,     -- designated timestamp (when exchange received)\n    gateway_ts TIMESTAMP,      -- when our gateway received\n    ack_ts TIMESTAMP,          -- when exchange acknowledged\n    symbol SYMBOL,\n    side SYMBOL,\n    qty DOUBLE\n) TIMESTAMP(exchange_ts) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE quotes (\n    exchange_ts TIMESTAMP,     -- when exchange published (designated)\n    received_ts TIMESTAMP,     -- when we received it\n    symbol SYMBOL,\n    bid DOUBLE,\n    ask DOUBLE\n) TIMESTAMP(exchange_ts) PARTITION BY DAY"
  },
  {
    "query": "SELECT * FROM quotes\nWHERE exchange_ts > dateadd('h', -1, now())"
  },
  {
    "query": "SELECT * FROM quotes\nWHERE received_ts > dateadd('h', -1, now())"
  },
  {
    "query": "SELECT * FROM (\n    SELECT ts, symbol, price FROM trades_2023\n    UNION ALL\n    SELECT ts, symbol, price FROM trades_2024\n    ORDER BY ts\n) TIMESTAMP(ts)\nSAMPLE BY 1h"
  },
  {
    "query": "SELECT timestamp, avg(price)\nFROM (\n    (SELECT * FROM read_parquet('trades.parquet') ORDER BY timestamp)\n    TIMESTAMP(timestamp)\n)\nSAMPLE BY 1m"
  },
  {
    "query": "SELECT * FROM recent SAMPLE BY 1h"
  },
  {
    "query": "SELECT table_name, designatedTimestamp\nFROM tables()\nWHERE table_name = 'trades'"
  },
  {
    "query": "SELECT \"column\", type, designated\nFROM table_columns('trades')"
  },
  {
    "query": "CREATE TABLE trades (\n  symbol SYMBOL,\n  side SYMBOL,\n  price DOUBLE,\n  amount DOUBLE,\n  timestamp TIMESTAMP\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "SELECT\n  timestamp,\n  symbol,\n  side,\n  sum(price * amount) AS notional\nFROM trades\nWHERE timestamp IN today()\nSAMPLE BY 1m"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_ohlc_15m AS\nSELECT\n  timestamp,\n  symbol,\n  first(price) AS open,\n  max(price) AS high,\n  min(price) AS low,\n  last(price) AS close,\n  sum(amount) AS volume\nFROM trades\nSAMPLE BY 15m"
  },
  {
    "query": "SELECT * FROM trades_ohlc_15m\nWHERE timestamp IN today()"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_with_metadata AS\nSELECT\n  t.timestamp,\n  t.symbol,\n  m.description,\n  sum(t.amount) AS volume\nFROM trades t\nJOIN instruments m ON t.symbol = m.symbol\nSAMPLE BY 1h",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE MATERIALIZED VIEW enriched_trades AS\nSELECT\n  t.timestamp,\n  t.symbol,\n  t.price,\n  t.amount,\n  h.hourly_vwap    -- aggregated value from another table\nFROM trades t\nASOF JOIN hourly_stats h ON t.symbol = h.symbol;",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS\nSELECT\n  timestamp,\n  symbol,\n  avg(price) AS avg_price,\n  sum(amount) AS volume\nFROM trades\nSAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_ohlc_15m\nWITH BASE trades REFRESH IMMEDIATE AS (\n  SELECT\n    timestamp,\n    symbol,\n    first(price) AS open,\n    max(price) AS high,\n    min(price) AS low,\n    last(price) AS close,\n    sum(amount) AS volume\n  FROM trades\n  SAMPLE BY 15m\n) PARTITION BY MONTH"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_daily\nREFRESH PERIOD (LENGTH 1d TIME ZONE 'Europe/London' DELAY 2h) AS\nSELECT\n  timestamp,\n  symbol,\n  avg(price) AS avg_price\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_daily\nREFRESH PERIOD (SAMPLE BY INTERVAL) AS\nSELECT timestamp, symbol, avg(price) AS avg_price\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "CREATE MATERIALIZED VIEW my_view AS (\n  SELECT timestamp, symbol, sum(amount) AS total_amount FROM trades SAMPLE BY 8h\n) PARTITION BY DAY"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS (\n  SELECT timestamp, symbol, avg(price) AS avg_price\n  FROM trades\n  SAMPLE BY 1h\n) PARTITION BY WEEK TTL 8 WEEKS"
  },
  {
    "query": "SELECT view_name, view_status, refresh_base_table_txn, base_table_txn\nFROM materialized_views()\nWHERE view_name = 'your_view'"
  },
  {
    "query": "SELECT\n  timestamp, symbol,\n  first(price) AS open, max(price) AS high,\n  min(price) AS low, last(price) AS close,\n  sum(amount) AS volume\nFROM trades\nWHERE timestamp > dateadd('M', -1, now())\nSAMPLE BY 15m"
  },
  {
    "query": "SELECT * FROM trades_ohlc_15m\nWHERE timestamp > dateadd('M', -1, now())"
  },
  {
    "query": "SELECT\n  view_name,\n  base_table_name,\n  view_status,\n  last_refresh_finish_timestamp\nFROM materialized_views()"
  },
  {
    "query": "SELECT\n  view_name,\n  refresh_base_table_txn,\n  base_table_txn,\n  base_table_txn - refresh_base_table_txn AS lag\nFROM materialized_views()"
  },
  {
    "query": "SELECT view_name, view_status, invalidation_reason\nFROM materialized_views()\nWHERE view_status = 'invalid'"
  },
  {
    "query": "REFRESH MATERIALIZED VIEW view_name FULL"
  },
  {
    "query": "SELECT * FROM trades LATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_latest_1d AS\nSELECT\n  timestamp,\n  symbol,\n  side,\n  last(price) AS price,\n  last(amount) AS amount,\n  last(timestamp) AS latest\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "SELECT symbol, side, price, amount, latest AS timestamp\nFROM (\n  trades_latest_1d\n  LATEST ON timestamp\n  PARTITION BY symbol, side\n)\nORDER BY timestamp DESC"
  },
  {
    "query": "SHOW PARTITIONS FROM trades"
  },
  {
    "query": "SELECT name, numRows, diskSizeHuman\nFROM table_partitions('trades')\nWHERE numRows > 1000000"
  },
  {
    "query": "ALTER TABLE trades SQUASH PARTITIONS"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,        -- Good: limited set of tickers\n    side SYMBOL,          -- Good: just BUY/SELL\n    price DOUBLE,\n    quantity DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE orders (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    side SYMBOL,\n    order_type SYMBOL,\n    price DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    client_id SYMBOL NOCACHE,\n    symbol SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "-- Disable cache\nALTER TABLE trades ALTER COLUMN client_id NOCACHE"
  },
  {
    "query": "-- Re-enable cache\nALTER TABLE trades ALTER COLUMN client_id CACHE"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL INDEX,\n    price DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "ALTER TABLE trades ALTER COLUMN symbol ADD INDEX"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2024-01-15T09:00@America/New_York;1h'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2024-01-[01..31]T09:00@Europe/London#wd;8h'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2024-01-[01..31]T09:30@America/New_York#wd;6h30m'"
  },
  {
    "query": "-- Last 5 business days, Tokyo morning session\nSELECT * FROM trades\nWHERE ts IN '[$today-5bd..$today-1bd]T09:00@Asia/Tokyo;2h30m'"
  },
  {
    "query": "SELECT\n    to_timezone(ts, 'Europe/Berlin') as local_time,\n    symbol,\n    price\nFROM trades\nWHERE ts IN '2024-01-15'"
  },
  {
    "query": "INSERT INTO trades\nSELECT to_utc(local_ts, 'America/New_York'), symbol, price\nFROM source_data"
  },
  {
    "query": "CREATE TABLE trades (\n    ts TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY TTL 7 DAYS"
  },
  {
    "query": "ALTER TABLE trades SET TTL 7 DAYS"
  },
  {
    "query": "-- These are equivalent\nALTER TABLE trades SET TTL 2 WEEKS"
  },
  {
    "query": "ALTER TABLE trades SET TTL 2w"
  },
  {
    "query": "SELECT table_name, ttlValue, ttlUnit FROM tables()"
  },
  {
    "query": "ALTER TABLE trades SET TTL 0"
  },
  {
    "query": "CREATE VIEW hourly_summary AS (\n  SELECT ts, symbol, sum(quantity) as volume\n  FROM trades\n  SAMPLE BY 1h\n)"
  },
  {
    "query": "SELECT * FROM hourly_summary WHERE symbol = 'AAPL'"
  },
  {
    "query": "CREATE VIEW daily_prices AS (\n  SELECT ts, symbol, last(price) as closing_price\n  FROM trades\n  SAMPLE BY 1d\n)"
  },
  {
    "query": "CREATE VIEW IF NOT EXISTS price_view AS (\n  SELECT symbol, last(price) as price FROM trades SAMPLE BY 1h\n)"
  },
  {
    "query": "CREATE OR REPLACE VIEW price_view AS (\n  SELECT symbol, last(price) as price, ts FROM trades SAMPLE BY 1h\n)"
  },
  {
    "query": "SELECT * FROM my_view"
  },
  {
    "query": "SELECT ts, price FROM my_view WHERE symbol = 'AAPL'"
  },
  {
    "query": "SELECT v1.ts, v2.value\nFROM view1 v1\nJOIN view2 v2 ON v1.id = v2.id"
  },
  {
    "query": "CREATE VIEW trades_view AS (\n  SELECT ts, symbol, price, quantity FROM trades WHERE price > 0\n)"
  },
  {
    "query": "SELECT ts, price FROM trades_view WHERE symbol = 'AAPL' ORDER BY ts\n-- Optimizer sees: SELECT ts, price FROM trades WHERE price > 0 AND symbol = 'AAPL' ORDER BY ts\n-- Only ts and price columns are read, filters applied at scan, ordering uses index"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades_view WHERE symbol = 'AAPL'"
  },
  {
    "query": "CREATE VIEW filtered_trades AS (\n  DECLARE OVERRIDABLE @min_price := 100\n  SELECT ts, symbol, price FROM trades WHERE price >= @min_price\n)"
  },
  {
    "query": "SELECT * FROM filtered_trades\n-- Uses default @min_price = 100"
  },
  {
    "query": "DECLARE @min_price := 500 SELECT * FROM filtered_trades\n-- Overrides @min_price to 500"
  },
  {
    "query": "CREATE VIEW price_range AS (\n  DECLARE OVERRIDABLE @lo := 100, OVERRIDABLE @hi := 1000\n  SELECT ts, symbol, price FROM trades WHERE price >= @lo AND price <= @hi\n)"
  },
  {
    "query": "-- Query with custom range\nDECLARE @lo := 50, @hi := 200 SELECT * FROM price_range"
  },
  {
    "query": "CREATE VIEW secure_view AS (\n  DECLARE @min_value := 0\n  SELECT * FROM trades WHERE value >= @min_value\n)"
  },
  {
    "query": "-- This will fail with \"variable is not overridable: @min_value\"\nDECLARE @min_value := -100 SELECT * FROM secure_view"
  },
  {
    "query": "CREATE VIEW mixed_params AS (\n  DECLARE @fixed_filter := 'active', OVERRIDABLE @limit := 100\n  SELECT * FROM data WHERE status = @fixed_filter LIMIT @limit\n)"
  },
  {
    "query": "-- @limit can be overridden, @fixed_filter cannot\nDECLARE @limit := 50 SELECT * FROM mixed_params"
  },
  {
    "query": "CREATE VIEW valid_trades AS (\n  SELECT * FROM trades WHERE price > 0 AND quantity > 0\n)"
  },
  {
    "query": "CREATE VIEW hourly_stats AS (\n  SELECT ts, symbol, sum(quantity) as volume\n  FROM valid_trades\n  SAMPLE BY 1h\n)"
  },
  {
    "query": "CREATE VIEW hourly_vwap AS (\n  SELECT ts, symbol, volume, turnover / volume as vwap\n  FROM hourly_stats\n  WHERE volume > 0\n)"
  },
  {
    "query": "SELECT * FROM views()"
  },
  {
    "query": "SHOW CREATE VIEW my_view"
  },
  {
    "query": "SHOW COLUMNS FROM my_view"
  },
  {
    "query": "ALTER VIEW my_view AS (SELECT col1, col2 FROM my_table WHERE col1 > 0)"
  },
  {
    "query": "DROP VIEW my_view"
  },
  {
    "query": "-- Or safely:\nDROP VIEW IF EXISTS my_view"
  },
  {
    "query": "SELECT view_name, view_status, invalidation_reason\nFROM views()\nWHERE view_status = 'invalid'"
  },
  {
    "query": "SELECT table_name, table_type FROM tables()"
  },
  {
    "query": "CREATE VIEW public_summary AS (\n  SELECT date, region, sum(sales) as total FROM sensitive_sales GROUP BY date, region\n)"
  },
  {
    "query": "-- Grant SELECT on the view to analysts\nGRANT SELECT ON public_summary TO analyst_role"
  },
  {
    "query": "SELECT * FROM public_summary"
  },
  {
    "query": "SELECT * FROM sensitive_sales"
  },
  {
    "query": "-- This works: grant SELECT on entire view\nGRANT SELECT ON my_view TO user1"
  },
  {
    "query": "CREATE TABLE employees (\n  id LONG,\n  name VARCHAR,\n  salary DOUBLE,        -- Sensitive\n  department VARCHAR,\n  hire_date TIMESTAMP\n)"
  },
  {
    "query": "CREATE VIEW employees_public AS (\n  SELECT id, name, department, hire_date\n  FROM employees\n)"
  },
  {
    "query": "-- Grant access to public view only\nGRANT SELECT ON employees_public TO analyst_role"
  },
  {
    "query": "CREATE VIEW desk_a_trades AS (\n  SELECT * FROM trades WHERE trader_id IN (101, 102, 103)\n)"
  },
  {
    "query": "GRANT SELECT ON desk_a_trades TO desk_a_users"
  },
  {
    "query": "EXPLAIN SELECT * FROM my_view WHERE symbol = 'AAPL'"
  },
  {
    "query": "CREATE TABLE prices (\n    ts TIMESTAMP,\n    ticker SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE static_data (key VARCHAR, value VARCHAR)"
  },
  {
    "query": "SELECT name, walEnabled FROM tables() WHERE name = 'prices'"
  },
  {
    "query": "SELECT * FROM wal_tables()"
  },
  {
    "query": "ALTER TABLE prices RESUME WAL"
  },
  {
    "query": "ALTER TABLE prices SET TYPE WAL"
  },
  {
    "query": "(SHOW PARAMETERS) WHERE reloadable = true",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM core_price\nWHERE timestamp IN '$today'\nLIMIT -10"
  },
  {
    "query": "SELECT timestamp, symbol,\n       array_count(bids[1]) as bid_levels,\n       array_count(asks[1]) as ask_levels\nFROM market_data\nWHERE timestamp IN '$today'\nLIMIT -5"
  },
  {
    "query": "SELECT * FROM fx_trades\nWHERE timestamp IN '$today'\nLIMIT -10"
  },
  {
    "query": "SELECT * FROM trades\nLIMIT -10"
  },
  {
    "query": "CREATE TABLE 'core_price' (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    ecn SYMBOL,\n    bid_price DOUBLE,\n    bid_volume LONG,\n    ask_price DOUBLE,\n    ask_volume LONG,\n    reason SYMBOL,\n    indicator1 DOUBLE,\n    indicator2 DOUBLE\n) timestamp(timestamp) PARTITION BY HOUR TTL 3 DAYS"
  },
  {
    "query": "CREATE TABLE 'market_data' (\n    timestamp TIMESTAMP,\n    symbol SYMBOL CAPACITY 16384 CACHE,\n    bids DOUBLE[][],\n    asks DOUBLE[][]\n) timestamp(timestamp) PARTITION BY HOUR TTL 3 DAYS"
  },
  {
    "query": "CREATE TABLE 'fx_trades' (\n    timestamp TIMESTAMP_NS,\n    symbol SYMBOL,\n    ecn SYMBOL,\n    trade_id UUID,\n    side SYMBOL,\n    passive BOOLEAN,\n    price DOUBLE,\n    quantity DOUBLE,\n    counterparty SYMBOL,\n    order_id UUID\n) timestamp(timestamp) PARTITION BY HOUR TTL 1 MONTH"
  },
  {
    "query": "CREATE TABLE 'trades' (\n    symbol SYMBOL CAPACITY 256 CACHE,\n    side SYMBOL CAPACITY 256 CACHE,\n    price DOUBLE,\n    amount DOUBLE,\n    timestamp TIMESTAMP\n) timestamp(timestamp) PARTITION BY DAY"
  },
  {
    "query": "SELECT table_name FROM tables()\nWHERE table_name LIKE 'sensor_%'"
  },
  {
    "query": "SELECT replace(names, ',', ' ASOF JOIN ') FROM tbs"
  },
  {
    "query": "SELECT string_agg(concat('avg(', table_name, '.value)'), ',') as columns\nFROM tables()\nWHERE table_name LIKE 'sensor_%'"
  },
  {
    "query": "SELECT sensor_1.timestamp, avg(sensor_1.value),avg(sensor_2.value),avg(sensor_3.value),avg(sensor_4.value)\nFROM sensor_1 ASOF JOIN sensor_2 ASOF JOIN sensor_3 ASOF JOIN sensor_4\nSAMPLE BY 1s FROM cast(1571176800000000 as timestamp) TO cast(1571349600000000 as timestamp) FILL(PREV)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT table_name FROM tables() WHERE table_name LIKE 'sensor_%'"
  },
  {
    "query": "SELECT timestamp as time, cumulative_value/cumulative_volume AS vwap_yesterday FROM cumulative"
  },
  {
    "query": "SELECT dateadd('d',-1,timestamp) as time, cumulative_value/cumulative_volume AS vwap_today FROM cumulative"
  },
  {
    "query": "SELECT concat(symbol, '#', price) FROM t"
  },
  {
    "query": "SELECT concat(symbol, '#', price, '#', volume) FROM trades"
  },
  {
    "query": "SELECT concat(name, '#', id) FROM users"
  },
  {
    "query": "SELECT concat(name, ' (', id, ')', '#', id) FROM users"
  },
  {
    "query": "SELECT\n  symbol AS __text,\n  price AS __value\nFROM trades\nWHERE symbol LIKE '%BTC%'"
  },
  {
    "query": "SELECT concat(symbol, '#', price) FROM trades\nORDER BY symbol"
  },
  {
    "query": "SELECT concat(symbol, '#', price) FROM trades\nORDER BY price DESC"
  },
  {
    "query": "SELECT concat(symbol, '#', price) FROM t\nORDER BY volume DESC"
  },
  {
    "query": "SELECT concat(symbol, ' (Vol: ', round(sum(amount), 2), ')', '#', first(price))\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT * FROM opcua_metrics\nORDER BY timestamp DESC\nLIMIT 10"
  },
  {
    "query": "SELECT *\nFROM wal_tables()\nWHERE name = 'core_price' AND writerTxn = sequencerTxn"
  },
  {
    "query": "CREATE TABLE trades_staging (\n  timestamp_ms LONG,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL INDEX,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "-- Convert and insert\nINSERT INTO trades\nSELECT\n  cast(timestamp_ms * 1000 AS TIMESTAMP) as timestamp,\n  symbol,\n  price,\n  amount\nFROM trades_staging"
  },
  {
    "query": "-- Drop staging table\nDROP TABLE trades_staging"
  },
  {
    "query": "SELECT * FROM cumulative_hist"
  },
  {
    "query": "-- Show all parameters modified from their defaults, via conf file or env variable\n(SHOW PARAMETERS) WHERE value_source <> 'default'",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT CAST('[\n  [ 1.0, 2.0, 3.0 ],\n  [\n    4.0,\n    5.0,\n    6.0\n  ]\n]' AS double[][]),\ncast('[[1,2,3],[4,5,6]]' as double[][])"
  },
  {
    "query": "SELECT\n  symbol,\n  count(CASE WHEN side = 'buy' THEN 1 END) as buy_count,\n  count(CASE WHEN side = 'sell' THEN 1 END) as sell_count,\n  avg(CASE WHEN side = 'buy' THEN price END) as avg_buy_price,\n  avg(CASE WHEN side = 'sell' THEN price END) as avg_sell_price,\n  sum(CASE WHEN amount > 1.0 THEN amount END) as large_trade_volume,\n  sum(CASE WHEN amount <= 1.0 THEN amount END) as small_trade_volume,\n  sum(amount) as total_volume\nFROM trades\nWHERE timestamp IN '$now - 1d..$now'\n  AND symbol IN ('BTC-USDT', 'ETH-USDT')\nGROUP BY symbol"
  },
  {
    "query": "DECLARE @bucket_size := 0.5\nSELECT\n  floor(amount / @bucket_size) * @bucket_size AS bucket,\n  count(*) AS count\nFROM trades\nWHERE symbol = 'BTC-USDT' AND timestamp IN '$today'\nGROUP BY bucket\nORDER BY bucket"
  },
  {
    "query": "DECLARE @bucket_count := 50\n\nWITH raw_data AS (\n  SELECT price, amount FROM trades\n  WHERE symbol = 'BTC-USDT' AND timestamp IN '$today'\n),\nbucket_size AS (\n  SELECT (max(price) - min(price)) / (@bucket_count - 1) AS bucket_size FROM raw_data\n)\nSELECT\n  floor(price / bucket_size) * bucket_size AS price_bin,\n  round(sum(amount), 2) AS volume\nFROM raw_data CROSS JOIN bucket_size\nGROUP BY 1\nORDER BY 1"
  },
  {
    "query": "SELECT\n  power(10, floor(log(amount))) AS bucket,\n  count(*) AS count\nFROM trades\nWHERE symbol = 'BTC-USDT'\n  AND amount > 0.000001 -- optional. Just adding here for easier visualization\n  AND timestamp IN '$today'\nGROUP BY bucket\nORDER BY bucket"
  },
  {
    "query": "SELECT\n  CASE\n    WHEN amount < 0.01 THEN 'micro'\n    WHEN amount < 0.1 THEN 'small'\n    WHEN amount < 1.0 THEN 'medium'\n    ELSE 'large'\n  END AS bucket,\n  count(*) AS count\nFROM trades\nWHERE symbol = 'BTC-USDT' AND timestamp IN '$today'\nGROUP BY bucket"
  },
  {
    "query": "DECLARE @bucket_size := 0.5\nSELECT\n  timestamp,\n  floor(amount / @bucket_size) * @bucket_size AS bucket,\n  count(*) AS count\nFROM trades\nWHERE symbol = 'BTC-USDT' AND timestamp IN '$today'\nSAMPLE BY 1h\nORDER BY timestamp, bucket"
  },
  {
    "query": "SELECT max(price), avg(price), min(price)\nFROM trades\nWHERE timestamp IN '2024-12-08'"
  },
  {
    "query": "SELECT max(count_sec) FROM (\n  SELECT count() as count_sec FROM trades\n  WHERE timestamp IN '2024-12-08'\n  SAMPLE BY 1s\n)"
  },
  {
    "query": "SELECT max(count_sec), max_min.* FROM (\n  SELECT count() as count_sec FROM trades\n  WHERE timestamp IN '2024-12-08'\n  SAMPLE BY 1s\n) CROSS JOIN max_min"
  },
  {
    "query": "SELECT timestamp, bid_price,\n  min(bid_price) OVER (ORDER BY timestamp RANGE 1 second PRECEDING) AS min_price,\n  max(bid_price) OVER (ORDER BY timestamp RANGE 1 second PRECEDING) AS max_price\nFROM core_price\nWHERE timestamp IN '$now - 1m..$now' AND symbol = 'EURUSD'"
  },
  {
    "query": "SELECT p.timestamp, p.bid_price,\n  min(pp.bid_price) AS min_price,\n  max(pp.bid_price) AS max_price\nFROM core_price p\nWINDOW JOIN core_price pp ON symbol\n  RANGE BETWEEN 1 second PRECEDING AND 1 second FOLLOWING\nWHERE p.timestamp IN '$now - 1m..$now' AND p.symbol = 'EURUSD'",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT timestamp, symbol, SUM(bid_volume) AS total_bid\nFROM core_price\nWHERE timestamp IN '$today'\nSAMPLE BY 1m\nLIMIT 20"
  },
  {
    "query": "SELECT timestamp,\n  SUM(CASE WHEN symbol = 'EURUSD' THEN bid_volume END) AS EURUSD,\n  SUM(CASE WHEN symbol = 'GBPUSD' THEN bid_volume END) AS GBPUSD,\n  SUM(CASE WHEN symbol = 'USDJPY' THEN bid_volume END) AS USDJPY,\n  SUM(CASE WHEN symbol NOT IN ('EURUSD', 'GBPUSD', 'USDJPY')\n    THEN bid_volume END) AS OTHERS\nFROM core_price\nWHERE timestamp IN '$today'\nSAMPLE BY 1m\nLIMIT 5"
  },
  {
    "query": "SELECT timestamp, bid_price,\n  LAG(bid_price, 1) OVER () AS prev_1,\n  LAG(bid_price, 2) OVER () AS prev_2,\n  LAG(bid_price, 3) OVER () AS prev_3,\n  LAG(bid_price, 4) OVER () AS prev_4,\n  LAG(bid_price, 5) OVER () AS prev_5,\n  LEAD(bid_price, 1) OVER () AS next_1,\n  LEAD(bid_price, 2) OVER () AS next_2,\n  LEAD(bid_price, 3) OVER () AS next_3,\n  LEAD(bid_price, 4) OVER () AS next_4,\n  LEAD(bid_price, 5) OVER () AS next_5\nFROM core_price\nWHERE timestamp IN '$now - 1m..$now' AND symbol = 'EURUSD'"
  },
  {
    "query": "CREATE TABLE events (\n    visitor_id SYMBOL,\n    pathname SYMBOL,\n    timestamp TIMESTAMP,\n    metric_name SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY MONTH WAL"
  },
  {
    "query": "SELECT * FROM EventsFullInfo"
  },
  {
    "query": "WITH totals AS (\n  SELECT\n    symbol,\n    count() as total\n  FROM trades\n  WHERE timestamp IN '$now - 1d..$now'\n),\nranked AS (\n  SELECT\n    *,\n    rank() OVER (ORDER BY total DESC) as ranking\n  FROM totals\n)\nSELECT\n  CASE\n    WHEN ranking <= 5 THEN symbol\n    ELSE '-Others-'\n  END as symbol,\n  SUM(total) as total_trades\nFROM ranked\nGROUP BY 1\nORDER BY total_trades DESC"
  },
  {
    "query": "WITH totals AS (\n  SELECT symbol, count() as total\n  FROM trades\n),\nranked AS (\n  SELECT *, row_number() OVER (ORDER BY total DESC) as rn\n  FROM totals\n)\nSELECT\n  CASE WHEN rn <= 5 THEN symbol ELSE '-Others-' END as symbol,\n  SUM(total) as total_trades\nFROM ranked\nGROUP BY 1\nORDER BY total_trades DESC"
  },
  {
    "query": "WITH totals AS (\n  SELECT symbol, count() as total\n  FROM trades\n  WHERE timestamp IN '$now - 1d..$now'\n),\nranked AS (\n  SELECT *, rank() OVER (ORDER BY total DESC) as ranking\n  FROM totals\n),\nsummed AS (\n  SELECT SUM(total) as grand_total FROM totals\n),\ngrouped AS (\n  SELECT\n    CASE WHEN ranking <= 5 THEN symbol ELSE '-Others-' END as symbol,\n    SUM(total) as total_trades\n  FROM ranked\n  GROUP BY 1\n)\nSELECT\n  symbol,\n  total_trades,\n  round(100.0 * total_trades / grand_total, 2) as percentage\nFROM grouped CROSS JOIN summed\nORDER BY total_trades DESC"
  },
  {
    "query": "WITH totals AS (\n  SELECT\n    symbol,\n    side,\n    count() as total\n  FROM trades\n  WHERE timestamp IN '$now - 1d..$now'\n),\nranked AS (\n  SELECT\n    *,\n    rank() OVER (PARTITION BY side ORDER BY total DESC) as ranking\n  FROM totals\n)\nSELECT\n  side,\n  CASE WHEN ranking <= 3 THEN symbol ELSE '-Others-' END as symbol,\n  SUM(total) as total_trades\nFROM ranked\nGROUP BY side, 2\nORDER BY side, total_trades DESC"
  },
  {
    "query": "SELECT\n  CASE\n    WHEN ranking <= 5 THEN symbol\n    WHEN ranking <= 10 THEN '-Top 10-'\n    ELSE '-Others-'\n  END as category,\n  SUM(total) as count\nFROM ranked\nGROUP BY 1"
  },
  {
    "query": "SELECT * FROM unpivoted\nWHERE price IS NOT NULL\nORDER BY timestamp"
  },
  {
    "query": "SELECT timestamp, sensor_id, 'pressure' as metric, pressure as value FROM sensor_data\nWHERE pressure IS NOT NULL\n\nORDER BY timestamp, sensor_id, metric"
  },
  {
    "query": "SELECT timestamp, symbol, 'buy' as side, buy as price FROM pivoted\nUNION ALL\nSELECT timestamp, symbol, 'sell' as side, sell as price FROM pivoted"
  },
  {
    "query": "WITH volumes AS (\n  SELECT\n    symbol,\n    SUM(CASE WHEN side = 'buy' THEN amount ELSE 0 END) AS buy_volume,\n    SUM(CASE WHEN side = 'sell' THEN amount ELSE 0 END) AS sell_volume\n  FROM trades\n  WHERE timestamp IN '$yesterday'\n    AND symbol IN ('ETH-USDT', 'BTC-USDT', 'ETH-BTC')\n)\nSELECT\n  symbol,\n  buy_volume,\n  sell_volume,\n  ((buy_volume - sell_volume)::double / (buy_volume + sell_volume)) * 100 AS imbalance\nFROM volumes"
  },
  {
    "query": "WITH OHLC AS (\n  SELECT\n    timestamp, symbol,\n      first(price) AS open,\n      max(price) as high,\n      min(price) as low,\n      last(price) AS close,\n      sum(quantity) AS volume\n FROM fx_trades\n WHERE symbol = 'EURUSD' AND timestamp IN '$yesterday'\n SAMPLE BY 15m\n), stats AS (\n  SELECT\n    timestamp,\n    close,\n    AVG(close) OVER (\n      ORDER BY timestamp\n      ROWS 19 PRECEDING\n    ) AS sma20,\n    AVG(close * close) OVER (\n      ORDER BY timestamp\n      ROWS 19 PRECEDING\n    ) AS avg_close_sq\n  FROM OHLC\n)\nSELECT\n  timestamp,\n  close,\n  sma20,\n  sqrt(avg_close_sq - (sma20 * sma20)) as stdev20,\n  sma20 + 2 * sqrt(avg_close_sq - (sma20 * sma20)) as upper_band,\n  sma20 - 2 * sqrt(avg_close_sq - (sma20 * sma20)) as lower_band\nFROM stats\nORDER BY timestamp"
  },
  {
    "query": "WITH OHLC AS (\n  SELECT\n    timestamp, symbol,\n      first(price) AS open,\n      last(price) AS close,\n      sum(quantity) AS volume\n FROM fx_trades\n WHERE symbol IN ('EURUSD', 'GBPUSD')\n   AND timestamp IN '$yesterday'\n SAMPLE BY 15m\n), stats AS (\n  SELECT\n    timestamp,\n    symbol,\n    close,\n    AVG(close) OVER (\n      PARTITION BY symbol\n      ORDER BY timestamp\n      ROWS 19 PRECEDING\n    ) AS sma20,\n    AVG(close * close) OVER (\n      PARTITION BY symbol\n      ORDER BY timestamp\n      ROWS 19 PRECEDING\n    ) AS avg_close_sq\n  FROM OHLC\n)\nSELECT\n  timestamp,\n  symbol,\n  close,\n  sma20,\n  sma20 + 2 * sqrt(avg_close_sq - (sma20 * sma20)) as upper_band,\n  sma20 - 2 * sqrt(avg_close_sq - (sma20 * sma20)) as lower_band\nFROM stats\nORDER BY symbol, timestamp"
  },
  {
    "query": "DECLARE\n  @symbol := 'BTC-USDT',\n  @history := '$now - 6M..$now',\n  @display := '$now - 1M..$now'\n\nWITH daily_ohlc AS (\n  SELECT\n    timestamp,\n    symbol,\n    first(open) AS open,\n    max(high) AS high,\n    min(low) AS low,\n    last(close) AS close\n  FROM trades_ohlc_15m\n  WHERE symbol = @symbol\n    AND timestamp IN @history\n  SAMPLE BY 1d\n),\nbands AS (\n  SELECT\n    timestamp,\n    symbol,\n    close,\n    AVG(close) OVER (\n      PARTITION BY symbol\n      ORDER BY timestamp\n      ROWS BETWEEN 19 PRECEDING AND CURRENT ROW\n    ) AS sma20,\n    AVG(close * close) OVER (\n      PARTITION BY symbol\n      ORDER BY timestamp\n      ROWS BETWEEN 19 PRECEDING AND CURRENT ROW\n    ) AS avg_close_sq\n  FROM daily_ohlc\n),\nbollinger AS (\n  SELECT\n    timestamp,\n    symbol,\n    close,\n    sma20,\n    sma20 + 2 * sqrt(avg_close_sq - (sma20 * sma20)) AS upper_band,\n    sma20 - 2 * sqrt(avg_close_sq - (sma20 * sma20)) AS lower_band\n  FROM bands\n),\nwith_bandwidth AS (\n  SELECT\n    timestamp,\n    symbol,\n    close,\n    sma20,\n    upper_band,\n    lower_band,\n    (upper_band - lower_band) / sma20 * 100 AS bandwidth\n  FROM bollinger\n),\nwith_range AS (\n  SELECT\n    timestamp,\n    symbol,\n    close,\n    sma20,\n    upper_band,\n    lower_band,\n    bandwidth,\n    min(bandwidth) OVER (PARTITION BY symbol) AS min_bw,\n    max(bandwidth) OVER (PARTITION BY symbol) AS max_bw\n  FROM with_bandwidth\n)\nSELECT\n  timestamp,\n  symbol,\n  round(close, 2) AS close,\n  round(sma20, 2) AS sma20,\n  round(upper_band, 2) AS upper_band,\n  round(lower_band, 2) AS lower_band,\n  round(bandwidth, 4) AS bandwidth,\n  round((bandwidth - min_bw) / (max_bw - min_bw) * 100, 1) AS range_position\nFROM with_range\nWHERE timestamp IN @display\nORDER BY timestamp"
  },
  {
    "query": "select timestamp, initial_principal, interest_rate,\ncoalesce(year_principal, initial_principal) as year_principal,\ncompounding_amount\nfrom compounding_year_before"
  },
  {
    "query": "WITH ln_values AS (\n    SELECT\n        date,\n        return,\n        SUM(ln(1 + return)) OVER (ORDER BY date) AS ln_value\n    FROM daily_returns\n)\nSELECT\n    date,\n    return,\n    100 * exp(ln_value) AS stock_price\nFROM ln_values"
  },
  {
    "query": "SELECT date, return, 1000 * exp(ln_value) AS stock_price  -- Start at $1000\nFROM ln_values"
  },
  {
    "query": "SELECT timestamp, 100 * exp(ln_value) AS price FROM ln_values"
  },
  {
    "query": "WITH ln_values AS (\n    SELECT\n        date,\n        symbol,\n        return,\n        SUM(ln(1 + return)) OVER (PARTITION BY symbol ORDER BY date) AS ln_value\n    FROM daily_returns\n)\nSELECT\n    date,\n    symbol,\n    100 * exp(ln_value) AS stock_price\nFROM ln_values"
  },
  {
    "query": "WITH latest_books AS (\n  SELECT timestamp, symbol, bids, asks\n  FROM market_data\n  WHERE timestamp IN '$today'\n  LATEST ON timestamp PARTITION BY symbol\n)\nSELECT\n  symbol,\n  L2PRICE(100_000, asks[2], asks[1]) AS buy_price,\n  L2PRICE(100_000, bids[2], bids[1]) AS sell_price,\n  L2PRICE(100_000, asks[2], asks[1]) - L2PRICE(100_000, bids[2], bids[1]) AS effective_spread,\n  (L2PRICE(100_000, asks[2], asks[1]) - L2PRICE(100_000, bids[2], bids[1])) /\n    ((L2PRICE(100_000, asks[2], asks[1]) + L2PRICE(100_000, bids[2], bids[1])) / 2) * 10_000 AS spread_bps\nFROM latest_books\nORDER BY spread_bps"
  },
  {
    "query": "SELECT\n  timestamp,\n  symbol,\n  last((L2PRICE(100_000, asks[2], asks[1]) - L2PRICE(100_000, bids[2], bids[1])) /\n    ((L2PRICE(100_000, asks[2], asks[1]) + L2PRICE(100_000, bids[2], bids[1])) / 2)) * 10_000 AS spread_bps\nFROM market_data\nWHERE timestamp IN '$today'\n  AND symbol IN ('EURUSD', 'GBPUSD', 'USDJPY')\nSAMPLE BY 1h\nORDER BY timestamp, symbol"
  },
  {
    "query": "WITH latest_books AS (\n  SELECT symbol, bids, asks\n  FROM market_data\n  WHERE timestamp IN '$today'\n  LATEST ON timestamp PARTITION BY symbol\n)\nSELECT\n  symbol,\n  L2PRICE(10_000, asks[2], asks[1]) - L2PRICE(10_000, bids[2], bids[1]) AS spread_10k,\n  L2PRICE(100_000, asks[2], asks[1]) - L2PRICE(100_000, bids[2], bids[1]) AS spread_100k,\n  L2PRICE(500_000, asks[2], asks[1]) - L2PRICE(500_000, bids[2], bids[1]) AS spread_500k,\n  L2PRICE(1_000_000, asks[2], asks[1]) - L2PRICE(1_000_000, bids[2], bids[1]) AS spread_1m\nFROM latest_books\nORDER BY symbol"
  },
  {
    "query": "SELECT\n  timestamp,\n  symbol,\n  first(price) AS open,\n  max(price) AS high,\n  min(price) AS low,\n  last(price) AS close,\n  sum(quantity) AS total_volume\nFROM fx_trades\nWHERE timestamp IN '$today'\nSAMPLE BY 1m"
  },
  {
    "query": "CREATE MATERIALIZED VIEW 'fx_trades_ohlc_1m' WITH BASE 'fx_trades' REFRESH IMMEDIATE AS (\n  SELECT\n    timestamp,\n    symbol,\n    first(price) AS open,\n    max(price) AS high,\n    min(price) AS low,\n    last(price) AS close,\n    sum(quantity) AS total_volume\n  FROM fx_trades\n  SAMPLE BY 1m\n) PARTITION BY HOUR TTL 2 DAYS"
  },
  {
    "query": "WITH stats AS (\n  SELECT\n    timestamp,\n    symbol,\n    price,\n    AVG(price) OVER (PARTITION BY symbol ORDER BY timestamp) AS rolling_avg,\n    AVG(price * price) OVER (PARTITION BY symbol ORDER BY timestamp) AS rolling_avg_sq\n  FROM fx_trades\n  WHERE timestamp IN '$yesterday' AND symbol = 'EURUSD'\n)\nSELECT\n  timestamp,\n  symbol,\n  price,\n  rolling_avg,\n  SQRT(rolling_avg_sq - rolling_avg * rolling_avg) AS rolling_stddev\nFROM stats\nLIMIT 10"
  },
  {
    "query": "WITH with_previous AS (\n  SELECT timestamp, symbol, price,\n    LAG(price) OVER (PARTITION BY symbol ORDER BY timestamp) AS prev_price\n  FROM fx_trades\n  WHERE timestamp IN '$today'\n),\nclassified AS (\n  SELECT  symbol,\n    CASE WHEN price > prev_price THEN 1 ELSE 0 END AS is_uptick,\n    CASE WHEN price < prev_price THEN 1 ELSE 0 END AS is_downtick\n  FROM with_previous\n  WHERE prev_price IS NOT NULL\n  LATEST ON timestamp PARTITION BY symbol -- use only the latest entry per symbol, together with the previous price\n)\nSELECT\n  SUM(is_uptick) AS uptick_symbols,\n  SUM(is_downtick) AS downtick_symbols,\n  SUM(is_uptick) - SUM(is_downtick) AS tick\nFROM classified"
  },
  {
    "query": "WITH daily_stats AS (\n  SELECT symbol,\n    first(price) AS open_price,\n    last(price) AS current_price,\n    sum(quantity) AS total_volume\n  FROM fx_trades\n  WHERE timestamp IN '$today'\n  SAMPLE BY 1d\n),\nclassified AS (\n  SELECT *,\n    CASE WHEN current_price > open_price THEN 1 ELSE 0 END AS is_advancing,\n    CASE WHEN current_price < open_price THEN 1 ELSE 0 END AS is_declining\n  FROM daily_stats\n)\nSELECT\n  SUM(is_advancing) AS advancing,\n  SUM(is_declining) AS declining,\n  SUM(CASE WHEN is_advancing = 1 THEN total_volume ELSE 0 END) AS advancing_volume,\n  SUM(CASE WHEN is_declining = 1 THEN total_volume ELSE 0 END) AS declining_volume,\n  (SUM(is_advancing)::double / NULLIF(SUM(is_declining), 0)) /\n  (SUM(CASE WHEN is_advancing = 1 THEN total_volume ELSE 0 END)::double /\n   NULLIF(SUM(CASE WHEN is_declining = 1 THEN total_volume ELSE 0 END), 0)) AS trin\nFROM classified"
  },
  {
    "query": "WITH candles AS (\n  SELECT timestamp, symbol,\n    last(price) AS close_price,\n    sum(quantity) AS total_volume\n  FROM fx_trades\n  WHERE timestamp IN '$today'\n  SAMPLE BY 5m\n),\nwith_previous AS (\n  SELECT timestamp, symbol, total_volume, close_price,\n    LAG(close_price) OVER (PARTITION BY symbol ORDER BY timestamp) AS last_close\n  FROM candles\n),\nclassified AS (\n  SELECT timestamp, symbol, total_volume,\n    CASE WHEN close_price > last_close THEN 1 ELSE 0 END AS is_advancing,\n    CASE WHEN close_price < last_close THEN 1 ELSE 0 END AS is_declining\n  FROM with_previous\n  WHERE last_close IS NOT NULL\n)\nSELECT\n  timestamp,\n  SUM(is_advancing) AS advancing,\n  SUM(is_declining) AS declining,\n  SUM(CASE WHEN is_advancing = 1 THEN total_volume ELSE 0 END) AS advancing_volume,\n  SUM(CASE WHEN is_declining = 1 THEN total_volume ELSE 0 END) AS declining_volume,\n  (SUM(is_advancing)::double / NULLIF(SUM(is_declining), 0)) /\n  (SUM(CASE WHEN is_advancing = 1 THEN total_volume ELSE 0 END)::double /\n   NULLIF(SUM(CASE WHEN is_declining = 1 THEN total_volume ELSE 0 END), 0)) AS trin\nFROM classified"
  },
  {
    "query": "DECLARE @tick_size := 1.0\nSELECT\n  floor(price / @tick_size) * @tick_size AS price_bin,\n  round(SUM(quantity), 2) AS volume\nFROM fx_trades\nWHERE symbol = 'EURUSD'\n  AND timestamp IN '$today'\nORDER BY price_bin"
  },
  {
    "query": "WITH raw_data AS (\n  SELECT price, quantity\n  FROM fx_trades\n  WHERE symbol = 'EURUSD' AND timestamp IN '$today'\n),\ntick_size AS (\n  SELECT (max(price) - min(price)) / 49 as tick_size\n  FROM raw_data\n)\nSELECT\n  floor(price / tick_size) * tick_size AS price_bin,\n  round(SUM(quantity), 2) AS volume\nFROM raw_data CROSS JOIN tick_size\nORDER BY 1"
  },
  {
    "query": "DECLARE\n  @range := '$now - 7h..$now',\n  @symbol := 'EURUSD'\nWITH candles AS (\n  SELECT\n    timestamp,\n    symbol,\n    sum(quantity) AS volume\n  FROM fx_trades\n  WHERE timestamp IN @range\n    AND symbol = @symbol\n  SAMPLE BY 30s\n),\nprev_volumes AS (\n  SELECT\n    timestamp,\n    symbol,\n    volume,\n    LAG(volume) OVER (PARTITION BY symbol ORDER BY timestamp) AS prev_volume\n  FROM candles\n)\nSELECT\n  *,\n  CASE\n    WHEN volume > 2 * prev_volume THEN 'spike'\n    ELSE 'normal'\n  END AS spike_flag\nFROM prev_volumes"
  },
  {
    "query": "WITH sampled AS (\n  SELECT\n    timestamp, symbol,\n    total_volume,\n    ((high + low + close) / 3) * total_volume AS traded_value\n  FROM fx_trades_ohlc_1m\n  WHERE timestamp IN '$yesterday' AND symbol = 'EURUSD'\n)\nSELECT\n  timestamp, symbol,\n  SUM(traded_value) OVER (ORDER BY timestamp) /\n    SUM(total_volume) OVER (ORDER BY timestamp) AS vwap\nFROM sampled"
  },
  {
    "query": "WITH sampled AS (\n  SELECT\n    timestamp, symbol,\n    total_volume,\n    ((high + low + close) / 3) * total_volume AS traded_value\n  FROM fx_trades_ohlc_1m\n  WHERE timestamp IN '$yesterday'\n    AND symbol IN ('EURUSD', 'GBPUSD', 'USDJPY')\n)\nSELECT\n  timestamp, symbol,\n  SUM(traded_value) OVER (PARTITION BY symbol ORDER BY timestamp) /\n    SUM(total_volume) OVER (PARTITION BY symbol ORDER BY timestamp) AS vwap\nFROM sampled"
  },
  {
    "query": "WITH\nsampled AS (\n  SELECT timestamp, operationId, sum(wh) as wh\n  FROM meter\n  SAMPLE BY 1h\n  FILL(0)\n),\nsessions AS (\n  SELECT *,\n    SUM(CASE WHEN wh > 0 THEN 1 END)\n      OVER (PARTITION BY operationId ORDER BY timestamp DESC) as session\n  FROM sampled\n),\ncounts AS (\n  SELECT timestamp, operationId,\n    FIRST_VALUE(wh) OVER (PARTITION BY operationId, session ORDER BY timestamp DESC) as wh,\n    COUNT(*) OVER (PARTITION BY operationId, session) as attributable_hours\n  FROM sessions\n)\nSELECT\n  timestamp,\n  operationId,\n  wh / attributable_hours as wh_avg\nFROM counts"
  },
  {
    "query": "SELECT\n  timestamp,\n  lag(timestamp) OVER (ORDER BY timestamp) AS prev_timestamp,\n  datediff('T', timestamp, lag(timestamp) OVER (ORDER BY timestamp)) AS elapsed_millis\nFROM trades\nWHERE symbol = 'BTC-USDT'\n  AND timestamp IN '$today'\nLIMIT 20"
  },
  {
    "query": "SELECT\n  timestamp,\n  timestamp - lag(timestamp) OVER (ORDER BY timestamp) AS elapsed_micros\nFROM trades\nWHERE symbol = 'BTC-USDT'\n  AND timestamp IN '$today'\nLIMIT 20"
  },
  {
    "query": "SELECT *\nFROM trades\nWHERE timestamp BETWEEN 1746552420000000 AND 1746811620000000"
  },
  {
    "query": "SELECT *\nFROM fx_trades\nWHERE timestamp BETWEEN 1768303754000000000 AND 1778303754000000000"
  },
  {
    "query": "SELECT timestamp, symbol, avg(bid_price) as bid_price, avg(ask_price) as ask_price\nFROM core_price\nWHERE symbol = 'EURUSD' AND timestamp IN '$today'\nSAMPLE BY 100T FILL(PREV, PREV)"
  },
  {
    "query": "SELECT timestamp, symbol, coalesce(bid_price, filler) as bid_price,\n       coalesce(ask_price, filler) as ask_price\nFROM with_previous_vals"
  },
  {
    "query": "SELECT timestamp, symbol, coalesce(bid_price, filler) as bid_price,\n       coalesce(ask_price, filler) as ask_price,\n       case when bid_price is NULL then true END as filled\nFROM with_previous_vals"
  },
  {
    "query": "SELECT * FROM sampled WHERE open IS NOT NULL AND symbol IN ('EURUSD', 'GBPUSD')"
  },
  {
    "query": "SELECT * FROM sampled WHERE timestamp >= @start_ts"
  },
  {
    "query": "SELECT * FROM trades\nWHERE week_of_year(timestamp) = 24"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp >= dateadd('w', 23, '2025-01-01')\n  AND timestamp < dateadd('w', 24, '2025-01-01')"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp >= @week_start\n  AND timestamp < @week_end"
  },
  {
    "query": "SELECT\n  TO_TIMESTAMP(timestamp::STRING, 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ') time,\n  symbol,\n  ecn,\n  bid_price\nFROM\n  core_price\nWHERE timestamp IN '$today'\nLIMIT 10"
  },
  {
    "query": "SELECT * FROM t LATEST BY symbol"
  },
  {
    "query": "(\n  SELECT * FROM\n  (\n    SELECT timestamp, symbol FROM core_price WHERE timestamp IN '$now - 1m..$now'\n    UNION ALL\n    SELECT timestamp, symbol FROM core_price WHERE timestamp IN '$now - 1m..$now'\n  ) ORDER BY timestamp\n)\nTIMESTAMP(timestamp)\nLIMIT 10",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT timestamp, avg(price)\nFROM ((read_parquet('trades.parquet') ORDER BY timestamp) TIMESTAMP(timestamp))\nSAMPLE BY 1m"
  },
  {
    "query": "SELECT *\nFROM my_table\nWHERE timestamp >= (\n  SELECT dateadd('m', -15, timestamp)\n  FROM my_table\n  LIMIT -1\n)"
  },
  {
    "query": "SELECT * FROM my_tb\nWHERE timestamp > dateadd('m', -15, now())"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp IN '$today'\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "SELECT timestamp, symbol, side, price, amount\nFROM ranked\nWHERE rn <= 5\nORDER BY symbol, timestamp DESC"
  },
  {
    "query": "SELECT * FROM ranked WHERE rn <= @limit"
  },
  {
    "query": "SELECT timestamp, symbol, side, price, amount\nFROM ranked\nWHERE rn <= 5"
  },
  {
    "query": "SELECT timestamp, symbol, price, rn as rank\nFROM ranked\nWHERE rn <= 5"
  },
  {
    "query": "SELECT * FROM trades\nWHERE symbol = 'BTC-USDT'\nORDER BY timestamp DESC\nLIMIT 100"
  },
  {
    "query": "SELECT * FROM trades\nWHERE symbol = 'BTC-USDT'\nLIMIT -100"
  },
  {
    "query": "WITH ranked AS (\n  SELECT\n    timestamp,\n    symbol,\n    price,\n    row_number() OVER (PARTITION BY symbol ORDER BY timestamp DESC) as rn\n  FROM trades\n  WHERE timestamp IN '$today'\n)\nSELECT\n  symbol,\n  count(*) as trade_count,\n  avg(price) as avg_price,\n  min(price) as min_price,\n  max(price) as max_price\nFROM ranked\nWHERE rn <= 10\nGROUP BY symbol"
  },
  {
    "query": "SELECT * FROM ranked WHERE rn <= 5"
  },
  {
    "query": "SELECT * FROM ranked WHERE rn <= 5 AND timestamp IN '$today'"
  },
  {
    "query": "SELECT\n    timestamp, symbol,\n    first(price) AS open,\n    last(price) AS close,\n    min(price),\n    max(price),\n    sum(quantity) AS volume\nFROM fx_trades\nWHERE symbol = 'EURUSD' AND timestamp IN '$now - 14d..$now'\nSAMPLE BY 1d"
  },
  {
    "query": "WITH moving_trades AS (\n  SELECT timestamp, symbol, price, quantity,\n    avg(price) OVER (\n      PARTITION BY symbol\n      ORDER BY timestamp\n      RANGE BETWEEN 7 days PRECEDING AND 1 day PRECEDING\n    ) AS moving_avg_price\n  FROM fx_trades\n  WHERE symbol = 'EURUSD' AND timestamp IN '$now - 21d..$now'\n)\nSELECT\n    timestamp, symbol,\n    first(price) AS open,\n    last(price) AS close,\n    min(price),\n    max(price),\n    sum(quantity) AS volume\nFROM moving_trades\nWHERE timestamp IN '$now - 14d..$now'\n  AND moving_avg_price IS NOT NULL\n  AND ABS(price - moving_avg_price) <= moving_avg_price * 0.01\nSAMPLE BY 1d"
  },
  {
    "query": "SELECT\n    dateadd('m', 15, timestamp) AS timestamp, symbol,\n    first(price) AS open,\n    last(price) AS close,\n    min(price),\n    max(price),\n    sum(quantity) AS volume\nFROM fx_trades\nWHERE symbol = 'EURUSD' AND timestamp IN '$today'\nSAMPLE BY 15m"
  },
  {
    "query": "WITH prevEvents AS (\n  SELECT *,\n    lag(lock_status::int) -- lag doesn't support booleans, so we convert to 1 or 0\n      OVER (PARTITION BY vehicle_id ORDER BY timestamp) as prev_status\n  FROM vehicle_events\n  WHERE timestamp IN '$today'\n),\nride_sessions AS (\n  SELECT *,\n    SUM(CASE\n      WHEN lock_status = true AND prev_status = 0 THEN 1\n      WHEN lock_status = false AND prev_status = 1 THEN 1\n      ELSE 0\n    END) OVER (PARTITION BY vehicle_id ORDER BY timestamp) as ride\n  FROM prevEvents\n),\nglobal_sessions AS (\n  SELECT *, concat(vehicle_id, '#', ride) as session\n  FROM ride_sessions\n),\ntotals AS (\n  SELECT\n    first(timestamp) as ts,\n    session,\n    FIRST(lock_status) as lock_status,\n    first(vehicle_id) as vehicle_id\n  FROM global_sessions\n  GROUP BY session\n),\nprev_ts AS (\n  SELECT *,\n    lag(timestamp) OVER (PARTITION BY vehicle_id ORDER BY timestamp) as prev_ts\n  FROM totals\n)\nSELECT\n  timestamp as ride_end,\n  vehicle_id,\n  datediff('s', prev_ts, timestamp) as duration_seconds\nFROM prev_ts\nWHERE lock_status = false AND prev_ts IS NOT NULL;",
    "skipAutocomplete": true
  },
  {
    "query": "WITH prevEvents AS (\n  SELECT *,\n    lag(lock_status::int) -- lag doesn't support booleans, so we convert to 1 or 0\n      OVER (PARTITION BY vehicle_id ORDER BY timestamp) as prev_status\n  FROM vehicle_events\n  WHERE timestamp IN '$now - 3M..$now'\n),\nride_sessions AS (\n  SELECT *,\n    SUM(CASE\n      WHEN lock_status = true AND prev_status = 0 THEN 1\n      WHEN lock_status = false AND prev_status = 1 THEN 1\n      ELSE 0\n    END) OVER (PARTITION BY vehicle_id ORDER BY timestamp) as ride\n  FROM prevEvents\n),\nglobal_sessions AS (\n  SELECT *, concat(vehicle_id, '#', ride) as session\n  FROM ride_sessions\n),\ntotals AS (\n  SELECT\n    first(timestamp) as ts,\n    session,\n    FIRST(lock_status) as lock_status,\n    first(vehicle_id) as vehicle_id\n  FROM global_sessions\n  GROUP BY session\n),\nprev_ts AS (\n  SELECT *,\n    lag(timestamp) OVER (PARTITION BY vehicle_id ORDER BY timestamp) as prev_ts\n  FROM totals\n)\nSELECT\n  timestamp_floor('M', timestamp) as month,\n  vehicle_id,\n  SUM(datediff('s', prev_ts, timestamp)) as total_ride_duration_seconds,\n  COUNT(*) as ride_count\nFROM prev_ts\nWHERE lock_status = false AND prev_ts IS NOT NULL\nGROUP BY month, vehicle_id\nORDER BY month, vehicle_id;",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE TABLE vehicle_events (\n  vehicle_id SYMBOL,\n  lock_status BOOLEAN,\n  timestamp TIMESTAMP\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "WITH prevEvents AS (\n  SELECT *,\n    lag(timestamp) OVER (PARTITION BY user_id ORDER BY timestamp) as prev_ts\n  FROM page_views\n),\nsessions AS (\n  SELECT *,\n    SUM(CASE\n      WHEN datediff('h', prev_ts, timestamp) > 1 THEN 1\n      ELSE 0\n    END) OVER (PARTITION BY user_id ORDER BY timestamp) as session_id\n  FROM prevEvents\n)\nSELECT\n  user_id,\n  session_id,\n  min(timestamp) as session_start,\n  max(timestamp) as session_end,\n  datediff('s', min(timestamp), max(timestamp)) as session_duration_seconds,\n  count(*) as page_views\nFROM sessions\nGROUP BY user_id, session_id"
  },
  {
    "query": "-- When machine changes from 'off' to 'running' to 'off'\nWITH prevStatus AS (\n  SELECT *,\n    lag(status) OVER (PARTITION BY machine_id ORDER BY timestamp) as prev_status\n  FROM machine_status\n),\ncycles AS (\n  SELECT *,\n    SUM(CASE\n      WHEN status != prev_status THEN 1\n      ELSE 0\n    END) OVER (PARTITION BY machine_id ORDER BY timestamp) as cycle\n  FROM prevStatus\n)\nSELECT\n  machine_id,\n  cycle,\n  min(timestamp) as cycle_start,\n  max(timestamp) as cycle_end\nFROM cycles\nWHERE status = 'running'\nGROUP BY machine_id, cycle"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    side SYMBOL,\n    price DOUBLE,\n    amount DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY\nDEDUP UPSERT KEYS(timestamp, symbol)"
  },
  {
    "query": "INSERT INTO trades\n    SELECT\n        timestamp_sequence('2024-01-01T00:00:00', 60000L * x) timestamp, -- Generate a timestamp every minute starting from Jan 1, 2024\n        rnd_str('ETH-USD', 'BTC-USD', 'SOL-USD', 'LTC-USD', 'UNI-USD') symbol, -- Random ticker symbols\n        rnd_str('buy', 'sell') side, -- Random side (BUY or SELL)\n        rnd_double() * 1000 + 100 price, -- Random price between 100.0 and 1100.0,\n        rnd_double() * 2000 + 0.1 amount -- Random price between 0.1 and 2000.1\n    FROM long_sequence(10000) x"
  },
  {
    "query": "CREATE TABLE quotes\nAS(\n    SELECT\n        x ID,\n        timestamp_sequence(to_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss'), rnd_long(1,10,0) * 100000L) ts,\n        rnd_double(0)*80 + 100 price,\n        rnd_long(0, 10000, 0) instrument_id\n    FROM long_sequence(10000000) x)\nTIMESTAMP(ts)\nPARTITION BY MONTH DEDUP UPSERT KEYS(ts, instrument_id)"
  },
  {
    "query": "CREATE TABLE instruments\nAS(\n    SELECT\n        x ID, -- Increasing integer\n        rnd_str('NYSE', 'NASDAQ', 'LSE', 'TSE', 'HKEX') exchange, -- Random exchange\n        rnd_str('Tech', 'Finance', 'Energy', 'Healthcare', 'Consumer') sector -- Random sector\n    FROM long_sequence(10000) x)"
  },
  {
    "query": "quotes",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT count() FROM quotes"
  },
  {
    "query": "SELECT avg(price) FROM quotes"
  },
  {
    "query": "SELECT *\nFROM quotes\nJOIN(\n    SELECT ID inst_id, exchange, sector\n    FROM instruments)\nON quotes.instrument_id = inst_id"
  },
  {
    "query": "SELECT sector, max(price)\nFROM quotes\nJOIN(\n    SELECT ID inst_id, sector\n    FROM instruments) a\nON quotes.instrument_id = a.inst_id"
  },
  {
    "query": "SELECT ts, sector, exchange, avg(price)\nFROM quotes timestamp(ts)\nJOIN\n    (SELECT ID inst_id, sector, exchange\n    FROM instruments\n    WHERE sector='Tech' AND exchange='NYSE') a\nON quotes.instrument_id = a.inst_id\nWHERE ts IN '2019-10-21;1d' -- this is an interval between 2019/10/21 and the next day\nSAMPLE BY 1h -- aggregation by hourly time buckets\nALIGN TO CALENDAR"
  },
  {
    "query": "DROP TABLE quotes"
  },
  {
    "query": "DROP TABLE instruments"
  },
  {
    "query": "DROP TABLE trades"
  },
  {
    "query": "SELECT reload_tls()"
  },
  {
    "query": "CREATE USER myadmin WITH PASSWORD 'xyz'"
  },
  {
    "query": "GRANT all TO myadmin WITH GRANT OPTION"
  },
  {
    "query": "CREATE USER readonly WITH PASSWORD 'xyz'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO readonly"
  },
  {
    "query": "GRANT SELECT ON ALL TABLES TO readonly"
  },
  {
    "query": "CREATE USER user1 WITH PASSWORD 'abc'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO user1"
  },
  {
    "query": "GRANT ALL ON table1 TO user1"
  },
  {
    "query": "CREATE USER user2 WITH PASSWORD 'abc'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO user2"
  },
  {
    "query": "GRANT ALL ON table2 TO user2 WITH GRANT OPTION"
  },
  {
    "query": "CREATE SERVICE ACCOUNT ingest_ilp"
  },
  {
    "query": "-- Grant permission to create tables and use HTTP endpoints\nGRANT HTTP, CREATE TABLE TO ingest_ilp"
  },
  {
    "query": "-- Grant permission to add columns and insert data\nGRANT ADD COLUMN, INSERT ON ALL TABLES TO ingest_ilp"
  },
  {
    "query": "ALTER SERVICE ACCOUNT ingest_ilp CREATE TOKEN TYPE REST WITH TTL '3000d' REFRESH"
  },
  {
    "query": "CREATE SERVICE ACCOUNT kafka"
  },
  {
    "query": "-- Grant permissions to use HTTP, create tables, add new columns and insert data\nGRANT HTTP, CREATE TABLE TO kafka"
  },
  {
    "query": "GRANT ADD COLUMN, INSERT ON ALL TABLES TO kafka"
  },
  {
    "query": "-- Creates a token that is valid for 1 year (365 days)\nALTER SERVICE ACCOUNT kafka CREATE TOKEN TYPE REST WITH TTL '365d'"
  },
  {
    "query": "CREATE SERVICE ACCOUNT dashboard WITH password 'pwd'"
  },
  {
    "query": "GRANT pgwire TO dashboard"
  },
  {
    "query": "GRANT select on all tables TO dashboard"
  },
  {
    "query": "CHECKPOINT CREATE"
  },
  {
    "query": "CREATE USER administrator WITH PASSWORD adminpwd"
  },
  {
    "query": "GRANT ALL TO administrator WITH GRANT OPTION"
  },
  {
    "query": "CREATE TABLE test (ts TIMESTAMP, val DOUBLE) TIMESTAMP(ts)"
  },
  {
    "query": "INSERT INTO test VALUES (now(), 42.5)"
  },
  {
    "query": "SELECT * FROM test"
  },
  {
    "query": "CREATE TABLE fx_prices (\n    pair SYMBOL,\n    bid DECIMAL(18,6),\n    ask DECIMAL(18,6),\n    notional DECIMAL(18,2),\n    fee DECIMAL(18,4),\n    ts TIMESTAMP\n) timestamp(ts)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE,\n  side SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE temps (device SYMBOL, location SYMBOL, value SHORT)"
  },
  {
    "query": "CREATE TABLE trade (ticker SYMBOL, price DECIMAL(18, 2))"
  },
  {
    "query": "CREATE TABLE tracking (\n    geohash GEOHASH(4b),\n    ts TIMESTAMP\n) TIMESTAMP(ts) PARTITION BY HOUR"
  },
  {
    "query": "CREATE TABLE trade (\n    ticker SYMBOL,\n    timestamp TIMESTAMP\n) TIMESTAMP(ts) PARTITION BY HOUR"
  },
  {
    "query": "CREATE TABLE trade (\n    ticker SYMBOL,\n    uuid UUID,\n    timestamp TIMESTAMP\n) TIMESTAMP(timestamp) PARTITION BY HOUR"
  },
  {
    "query": "CREATE TABLE trade (\n    ticker SYMBOL,\n    price DECIMAL(18, 2),\n    timestamp TIMESTAMP\n) TIMESTAMP(timestamp) PARTITION BY HOUR"
  },
  {
    "query": "CREATE TABLE IF NOT EXISTS 'trades' (\n  symbol SYMBOL capacity 256 CACHE,\n  side SYMBOL capacity 256 CACHE,\n  price DOUBLE,\n  amount DOUBLE,\n  my_ts TIMESTAMP\n) timestamp (my_ts) PARTITION BY DAY WAL"
  },
  {
    "query": "CREATE SERVICE ACCOUNT ingest_user"
  },
  {
    "query": "-- creates a service account to be used by a client\nGRANT ilp, create table TO ingest_user"
  },
  {
    "query": "-- grants permissions to ingest data and create tables\nGRANT add column, insert ON all tables TO ingest_user"
  },
  {
    "query": "-- grants permissions to add columns and insert data to all tables\n--  OR\nGRANT add column, insert ON table1, table2 TO ingest_user"
  },
  {
    "query": "COPY weather from 'test_file.csv' WITH HEADER true"
  },
  {
    "query": "CREATE TABLE 'weather' (\n     timestamp TIMESTAMP,\n     windDir INT,\n     windSpeed INT,\n     windGust INT,\n     cloudCeiling INT,\n     skyCover VARCHAR,\n     visMiles DOUBLE,\n     tempF INT,\n     dewpF INT,\n     rain1H DOUBLE,\n     rain6H DOUBLE,\n     rain24H DOUBLE,\n     snowDepth INT\n   )"
  },
  {
    "query": "SELECT * FROM sys.text_import_log WHERE id = '5179978a6d7a1772' ORDER BY ts DESC"
  },
  {
    "query": "TRUNCATE TABLE table_name"
  },
  {
    "query": "DROP TABLE table_name"
  },
  {
    "query": "CREATE TABLE 'weather' (\n     timestamp TIMESTAMP,\n     windDir INT,\n     windSpeed INT,\n     windGust INT,\n     cloudCeiling INT,\n     skyCover VARCHAR,\n     visMiles DOUBLE,\n     tempF INT,\n     dewpF INT,\n     rain1H DOUBLE,\n     rain6H DOUBLE,\n     rain24H DOUBLE,\n     snowDepth INT\n   ) TIMESTAMP (timestamp) partition by DAY"
  },
  {
    "query": "COPY weather FROM 'weather.csv' WITH HEADER true TIMESTAMP 'timestamp' FORMAT 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ'"
  },
  {
    "query": "SELECT * FROM sys.text_import_log WHERE id = '55020329020b446a'"
  },
  {
    "query": "SELECT * FROM sys.text_import_log WHERE id = '55020329020b446a' ORDER BY ts DESC"
  },
  {
    "query": "CREATE TABLE table_name (\n  ts TIMESTAMP,\n  sym SYMBOL CAPACITY 100000\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "COPY weather from 'weather_example.csv' WITH HEADER true"
  },
  {
    "query": "INSERT BATCH 100000 INTO table_name\nSELECT * FROM other_table"
  },
  {
    "query": "COPY 'paste_import_id_here' CANCEL"
  },
  {
    "query": "SELECT * FROM sys.text_import_log LIMIT -10"
  },
  {
    "query": "ALTER TABLE table_name RENAME COLUMN f0 TO ts"
  },
  {
    "query": "INSERT INTO Orders values (0, 42, 'IBM')"
  },
  {
    "query": "SELECT * FROM Orders"
  },
  {
    "query": "SELECT * FROM example_table"
  },
  {
    "query": "SELECT *\nFROM redpanda_connect_demo"
  },
  {
    "query": "CREATE TABLE trades (\n  symbol SYMBOL,\n  side SYMBOL,\n  price DOUBLE,\n  amount DOUBLE,\n  timestamp TIMESTAMP\n) timestamp (timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades_enriched (\n  symbol SYMBOL,\n  volume DOUBLE,\n  mid DOUBLE,\n  ts TIMESTAMP,\n  ma10 DOUBLE,\n  std DOUBLE\n) timestamp (ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO trades SELECT * FROM (\n  SELECT 'BTC-USD' symbol,\n  rnd_symbol('buy', 'sell') side,\n  rnd_double() * 10000 price,\n  rnd_double() amount,\n  timestamp_sequence(1677628800000000, 10000000) ts\n  FROM long_sequence(25920)\n) timestamp (ts)"
  },
  {
    "query": "SELECT * FROM trades_enriched"
  },
  {
    "query": "SELECT * FROM your_table LIMIT 10"
  },
  {
    "query": "SELECT * FROM cpu"
  },
  {
    "query": "SELECT * FROM mem"
  },
  {
    "query": "CREATE TABLE my_table (\n    id INT,\n    name STRING,\n    created_at TIMESTAMP\n) timestamp(created_at)"
  },
  {
    "query": "SELECT COUNT(*) FROM my_table"
  },
  {
    "query": "RENAME TABLE 'coin_Ethereum.csv' TO 'ethereum'"
  },
  {
    "query": "CREATE TABLE IF NOT EXISTS house_rentals_data (\n    number_of_rooms INT,\n    number_of_bathrooms INT,\n    sqft INT,\n    location SYMBOL,\n    days_on_market INT,\n    initial_price FLOAT,\n    neighborhood SYMBOL,\n    rental_price FLOAT,\n    ts TIMESTAMP\n) TIMESTAMP(ts) PARTITION BY YEAR"
  },
  {
    "query": "INSERT INTO house_rentals_data SELECT * FROM (\n    SELECT\n        rnd_int(1,6,0),\n        rnd_int(1,3,0),\n        rnd_int(180,2000,0),\n        rnd_symbol('great', 'good', 'poor'),\n        rnd_int(1,20,0),\n        rnd_float(0) * 1000,\n        rnd_symbol('alcatraz_ave', 'berkeley_hills', 'downtown', 'south_side', 'thowsand_oaks', 'westbrae'),\n        rnd_float(0) * 1000 + 500,\n        timestamp_sequence(\n            to_timestamp('2021-01-01', 'yyyy-MM-dd'),\n            14400000000L\n        )\n    FROM long_sequence(100)\n)"
  },
  {
    "query": "CREATE TABLE sample_query_results AS (\n    SELECT\n        ts,\n        neighborhood,\n        sum(days_on_market) DaysLive,\n        min(rental_price) MinRent,\n        max(rental_price) MaxRent,\n        avg(rental_price) AvgRent\n    FROM house_rentals_data\n    WHERE ts BETWEEN '2021-01-08' AND '2021-01-10'\n    SAMPLE BY 1d FILL (0, 0, 0, 0)\n) TIMESTAMP(ts) PARTITION BY MONTH"
  },
  {
    "query": "-- Get 1-hour samples of trade prices\nSELECT\n    timestamp,\n    avg(price) as avg_price,\n    sum(amount) as volume\nFROM trades\nWHERE timestamp >= dateadd('d', -7, now())\nSAMPLE BY 1h"
  },
  {
    "query": "SELECT * FROM trades\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "SELECT \n    timestamp,\n    symbol,\n    max(price) max_price,\n    min(price) min_price,\n    avg(price) avg_price\nFROM trades\nWHERE timestamp >= dateadd('M', -1, now())\nSAMPLE BY 1d\nALIGN TO CALENDAR"
  },
  {
    "query": "BACKUP DATABASE"
  },
  {
    "query": "SELECT * FROM backups()"
  },
  {
    "query": "BACKUP ABORT"
  },
  {
    "query": "SELECT backup_instance_name"
  },
  {
    "query": "SELECT start_ts FROM backups() WHERE status = 'backup complete'"
  },
  {
    "query": "SELECT * FROM checkpoint_status()"
  },
  {
    "query": "CHECKPOINT RELEASE"
  },
  {
    "query": "CREATE TABLE my_table(ts TIMESTAMP, symb SYMBOL, price DOUBLE) timestamp(ts)\nPARTITION BY DAY"
  },
  {
    "query": "--Delete a partition\n  ALTER TABLE my_table DROP PARTITION LIST '2021-01-01'"
  },
  {
    "query": "--Delete a list of two partitions\n  ALTER TABLE my_table DROP PARTITION LIST '2021-01-01', '2021-01-02'"
  },
  {
    "query": "ALTER TABLE my_table DROP PARTITION\n  WHERE timestamp = to_timestamp('2021-01-01', 'yyyy-MM-dd')"
  },
  {
    "query": "--Drop partitions older than 30 days\n  ALTER TABLE my_table DROP PARTITION\n  WHERE timestamp < dateadd('d', -30, now())"
  },
  {
    "query": "CREATE TABLE my_table (timestamp TIMESTAMP, x LONG) timestamp(timestamp)\nPARTITION BY DAY"
  },
  {
    "query": "INSERT INTO my_table\nSELECT timestamp_sequence(\n    to_timestamp('2021-01-01T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),100000L * 36000), x\nFROM long_sequence(120)"
  },
  {
    "query": "CREATE TABLE takeaway_order (\n    ts TIMESTAMP,\n    id SYMBOL,\n    status SYMBOL)\n        timestamp(ts)"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order1', 'placed')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order2', 'placed')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order1', 'cooking')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order1', 'in-transit')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order1', 'arrived')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order3', 'placed')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order3', 'cooking')"
  },
  {
    "query": "INSERT INTO takeaway_order VALUES (now(), 'order3', 'in-transit')"
  },
  {
    "query": "WITH\n    ts_takeaway_order AS (\n        SELECT\n            max(ts) AS ts,\n            id\n        FROM\n            takeaway_order GROUP BY id)\nSELECT\n    o.*\nFROM\n    ts_takeaway_order ts_o\n    INNER JOIN 'takeaway_order' o\n    ON ts_o.ts = o.ts"
  },
  {
    "query": "CREATE TABLE mytable_copy AS (\n    SELECT * FROM mytable WHERE column_value != 42\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "DROP TABLE mytable"
  },
  {
    "query": "RENAME table mytable_copy TO mytable"
  },
  {
    "query": "SELECT\n    table_name,\n    table_row_count,\n    wal_pending_row_count,\n    CASE\n        WHEN table_suspended THEN 'SUSPENDED'\n        WHEN table_memory_pressure_level = 2 THEN 'BACKOFF'\n        WHEN table_memory_pressure_level = 1 THEN 'PRESSURE'\n        ELSE 'OK'\n    END AS status,\n    wal_txn - table_txn AS lag_txns,\n    table_write_amp_p50 AS write_amp,\n    table_merge_rate_p99 AS slowest_merge\nFROM tables()\nWHERE walEnabled\nORDER BY\n    table_suspended DESC,\n    table_memory_pressure_level DESC,\n    wal_pending_row_count DESC"
  },
  {
    "query": "SELECT table_name FROM tables() WHERE table_suspended"
  },
  {
    "query": "ALTER TABLE my_table RESUME WAL"
  },
  {
    "query": "-- Find the last applied transaction\nSELECT writerTxn FROM wal_tables() WHERE name = 'my_table'"
  },
  {
    "query": "SELECT view_name, invalidation_reason\nFROM materialized_views()\nWHERE view_status = 'invalid'"
  },
  {
    "query": "REFRESH MATERIALIZED VIEW my_view FULL"
  },
  {
    "query": "SELECT table_name,\n       CASE table_memory_pressure_level\n           WHEN 1 THEN 'PRESSURE'\n           WHEN 2 THEN 'BACKOFF'\n       END AS status\nFROM tables()\nWHERE table_memory_pressure_level > 0"
  },
  {
    "query": "SELECT table_name, wal_tx_size_p50, wal_tx_size_p90, wal_tx_size_max\nFROM tables()\nWHERE walEnabled\n  AND wal_tx_size_p90 > 0\n  AND wal_tx_size_p90 < 100"
  },
  {
    "query": "SELECT table_name,\n       table_write_amp_p50,\n       table_write_amp_p99,\n       table_merge_rate_p99 AS slowest_merge\nFROM tables()\nWHERE walEnabled\n  AND table_write_amp_p50 > 3.0\nORDER BY table_write_amp_p99 DESC"
  },
  {
    "query": "SELECT table_name,\n       wal_txn - table_txn AS pending_txns,\n       wal_pending_row_count\nFROM tables()\nWHERE walEnabled\n  AND (wal_txn - table_txn > 10 OR wal_pending_row_count > 1000000)\nORDER BY wal_pending_row_count DESC"
  },
  {
    "query": "CREATE TABLE tango AS (SELECT ARRAY[\n   [ [ 1,  2,  3], [ 4,  5,  6], [ 7,  8,  9] ],\n   [ [10, 11, 12], [13, 14, 15], [16, 17, 18] ],\n   [ [19, 20, 21], [22, 23, 24], [25, 26, 27] ]\n] arr from long_sequence(1))"
  },
  {
    "query": "CREATE TABLE tango AS (SELECT ARRAY[1, 2] arr, ARRAY[3, 4] brr FROM long_sequence(1))"
  },
  {
    "query": "SELECT ARRAY[arr, brr] FROM tango"
  },
  {
    "query": "SELECT arr[1, 3, 2] elem FROM tango"
  },
  {
    "query": "SELECT arr[1, 3, 4] elem FROM tango"
  },
  {
    "query": "SELECT arr[1] subarr FROM tango"
  },
  {
    "query": "SELECT arr[4] subarr FROM tango"
  },
  {
    "query": "SELECT arr[1, 3] subarr FROM tango"
  },
  {
    "query": "SELECT arr[2:3] slice FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT arr[2:] slice FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT arr[2:3, 3:4] slice FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT arr[2:100, 3:100] slice FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT arr[1, 2:4] subarr FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT arr[1:, 3, 2] subarr FROM tango",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT\n  ARRAY[1, 2, 3] = ARRAY[1, 2, 3] as same,\n  ARRAY[1, 2, 3] = ARRAY[1, 2, 4] as different_value,\n  ARRAY[1, 2, 3] = ARRAY[[1, 2, 3]] as different_shape"
  },
  {
    "query": "SELECT ARRAY[1, NULL, 3] = ARRAY[1, NULL, 3] as with_nulls"
  },
  {
    "query": "SELECT 123.45m"
  },
  {
    "query": "SELECT 0.001m"
  },
  {
    "query": "SELECT 1000000.00m"
  },
  {
    "query": "SELECT 123.45"
  },
  {
    "query": "CREATE TABLE eth_fills (\n    fill_id LONG,\n    venue SYMBOL,\n    fill_size_eth DECIMAL(28, 18),   -- ETH quantity with wei-level precision\n    fill_price_usdc DECIMAL(14, 2),  -- Execution price per ETH in USDC\n    fee_rate DECIMAL(6, 5),          -- Exchange fee rate (e.g., 0.00050 = 5 bps)\n    gas_fee_eth DECIMAL(20, 18),     -- Gas paid in ETH\n    timestamp TIMESTAMP\n) timestamp(timestamp) partition by day"
  },
  {
    "query": "-- Insert ETH fill data\nINSERT INTO eth_fills VALUES\n    (1, 'spot:coinbase', 0.842345678901234567m, 2123.45m, 0.00040m, 0.002300000000000000m, now()),\n    (2, 'perp:binance', 5.250000000000000000m, 2118.10m, 0.00020m, 0.001200000000000000m, now()),\n    (3, 'defi:uniswap', 18.750000000000000000m, 2115.05m, 0.00065m, 0.004500000000000000m, now())"
  },
  {
    "query": "-- Arithmetic operations maintain precision\nSELECT\n    venue,\n    fill_size_eth,\n    fill_price_usdc,\n    fill_size_eth * fill_price_usdc AS notional_usdc,\n    fill_size_eth * fill_price_usdc * fee_rate AS fee_usdc,\n    gas_fee_eth * fill_price_usdc AS gas_cost_usdc,\n    fill_size_eth - gas_fee_eth AS net_eth_after_gas,\n    fill_size_eth * fill_price_usdc\n        - fill_size_eth * fill_price_usdc * fee_rate\n        - gas_fee_eth * fill_price_usdc AS net_settlement_usdc\nFROM eth_fills"
  },
  {
    "query": "SELECT 10.5m + 1.234m"
  },
  {
    "query": "SELECT 99999999.99m + 999999.99m"
  },
  {
    "query": "SELECT 10.50m * 1.25m"
  },
  {
    "query": "SELECT 100.50m * 12.34m"
  },
  {
    "query": "SELECT 10.50m / 2.0m"
  },
  {
    "query": "SELECT 10.00m / 3.00m"
  },
  {
    "query": "SELECT * FROM eth_fills WHERE fill_size_eth >= 10.000000000000000000m"
  },
  {
    "query": "SELECT * FROM eth_fills WHERE fee_rate <= 0.00025m"
  },
  {
    "query": "SELECT * FROM eth_fills WHERE fill_price_usdc BETWEEN 2100.00m AND 2200.00m"
  },
  {
    "query": "SELECT CAST(100 AS DECIMAL(10, 2))"
  },
  {
    "query": "SELECT CAST(123.456789 AS DECIMAL(8, 3))"
  },
  {
    "query": "SELECT CAST(99.99m AS INT)"
  },
  {
    "query": "SELECT CAST(99.99m AS DOUBLE)"
  },
  {
    "query": "CREATE TABLE portfolio (\n    symbol SYMBOL,\n    position_size DECIMAL(12, 4),     -- Fractional position sizes (shares, BTC, etc.) supported\n    price DECIMAL(10, 2),       -- Stock price\n    commission DECIMAL(7, 2),   -- Trading fees\n    timestamp TIMESTAMP\n) timestamp(timestamp)"
  },
  {
    "query": "-- Calculate exact portfolio value\nSELECT\n    symbol,\n    position_size,\n    price,\n    position_size * price AS position_value,\n    position_size * price - commission AS net_value,\n    sum(position_size * price) OVER () AS total_portfolio_value\nFROM portfolio\nWHERE timestamp = now()"
  },
  {
    "query": "CREATE TABLE crypto_trades (\n    trade_id LONG,\n    pair SYMBOL,\n    eth_amount DECIMAL(28, 18),      -- ETH with full wei precision\n    usdt_price DECIMAL(12, 2),        -- USDT price per ETH\n    fee_rate DECIMAL(5, 4),           -- Trading fee (e.g., 0.001 for 0.1%)\n    gas_fee_eth DECIMAL(18, 18),      -- Gas fee in ETH\n    timestamp TIMESTAMP\n) timestamp(timestamp)"
  },
  {
    "query": "-- Calculate trade values with exact precision\nSELECT\n    trade_id,\n    eth_amount,\n    usdt_price,\n    eth_amount * usdt_price AS trade_value_usdt,\n    eth_amount * usdt_price * fee_rate AS fee_usdt,\n    eth_amount * usdt_price * (1.0m - fee_rate) AS net_value_usdt,\n    eth_amount - gas_fee_eth AS net_eth_received\nFROM crypto_trades"
  },
  {
    "query": "CREATE TABLE sensor_readings (\n    sensor_id SYMBOL,\n    measurement DECIMAL(20, 10),  -- 10 decimal places of precision\n    calibration_factor DECIMAL(6, 5),\n    timestamp TIMESTAMP\n) timestamp(timestamp)"
  },
  {
    "query": "-- Apply calibration with exact arithmetic\nSELECT\n    sensor_id,\n    measurement,\n    measurement * calibration_factor AS calibrated_value,\n    avg(measurement) OVER (PARTITION BY sensor_id) AS avg_reading\nFROM sensor_readings\nSAMPLE BY 1h"
  },
  {
    "query": "-- Good: Matches business requirements\n   CREATE TABLE prices (\n       amount DECIMAL(10, 2)  -- Cents precision for USD\n   )"
  },
  {
    "query": "-- Avoid: Excessive precision\n   CREATE TABLE prices (\n       amount DECIMAL(30, 15)  -- Unnecessary for most use cases\n   )"
  },
  {
    "query": "-- Good: Clear decimal literals\n   INSERT INTO prices VALUES (99.99m)"
  },
  {
    "query": "-- Error: Missing 'm' suffix\n   INSERT INTO prices VALUES (99.99)"
  },
  {
    "query": "SELECT amount + CAST(10 AS DECIMAL(10, 2)) FROM prices"
  },
  {
    "query": "SELECT amount + 10.00m FROM prices"
  },
  {
    "query": "CREATE TABLE geo_data (g5c geohash(5c), g29b geohash(29b))"
  },
  {
    "query": "INSERT INTO geo_data VALUES(#u33d8, ##10101111100101111111101101101)"
  },
  {
    "query": "SELECT * FROM geo_data WHERE g5c = #u33d8"
  },
  {
    "query": "INSERT INTO my_geo_data VALUES(#u33, #u33d8b12)"
  },
  {
    "query": "-- insert a 5-bit geohash into a 4 bit column\nINSERT INTO my_geo_data VALUES(#a/4)"
  },
  {
    "query": "-- insert a 20-bit geohash into an 18 bit column\nINSERT INTO my_geo_data VALUES(#u33d/18)"
  },
  {
    "query": "INSERT INTO my_geo_data VALUES(##0111001001001001000111000110)"
  },
  {
    "query": "-- equivalent to\nINSERT INTO my_geo_data VALUES('u33', 'u33d8b12')"
  },
  {
    "query": "CREATE TABLE new_table AS (\nSELECT cast(null AS geohash(4c)) gh4c\nFROM source_table WHERE 1 != 1\n)"
  },
  {
    "query": "SELECT make_geohash(142.89124148, -12.90604153, 40)"
  },
  {
    "query": "CREATE TABLE my_geo_data (g1c geohash(1c), g8c geohash(8c))"
  },
  {
    "query": "INSERT INTO my_geo_data values(#u, #u33d8b12)"
  },
  {
    "query": "-- SQL will execute successfully with 'u33d8b12' truncated to 'u'\nINSERT INTO my_geo_data values(#u33d8b12, #eet531sq)"
  },
  {
    "query": "-- ERROR as '#e' is too short to insert into 8c_geohash column\nINSERT INTO my_geo_data values(#u, #e)"
  },
  {
    "query": "CREATE TABLE geo_data\n  (ts timestamp,\n  device_id symbol,\n  g1c geohash(1c),\n  g8c geohash(8c)),\nindex(device_id) timestamp(ts)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_1', #u, #u33d8b12)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_1', #u, #u33d8b18)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_2', #e, #ezzn5kxb)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_1', #u, #u33d8b1b)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_2', #e, #ezzn5kxc)"
  },
  {
    "query": "INSERT INTO geo_data values(now(), 'device_3', #e, #u33dr01d)"
  },
  {
    "query": "SELECT * FROM geo_data\nWHERE g8c = #u33dr01d\nLATEST ON ts PARTITION BY device_id"
  },
  {
    "query": "SELECT ts, last(g8c) FROM geo_data WHERE device_id = 'device_3'"
  },
  {
    "query": "SELECT ts, last(g8c), first(g8c) FROM geo_data\nWHERE device_id = 'device_3' sample by 1h"
  },
  {
    "query": "SELECT * FROM geo_data\nWHERE g8c within(#u33d)\nLATEST ON ts PARTITION BY device_id"
  },
  {
    "query": "CREATE TABLE tracking (ts timestamp, geohash geohash(8c))"
  },
  {
    "query": "CREATE TABLE prices (\n    ts TIMESTAMP,\n    amount DECIMAL(18, 6)  -- 18 total digits, 6 after decimal point\n) TIMESTAMP(ts)"
  },
  {
    "query": "CREATE TABLE my_table (\n    id UUID\n)"
  },
  {
    "query": "SELECT * FROM my_table WHERE id = 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'"
  },
  {
    "query": "CREATE TABLE traffic (ts timestamp, src ipv4, dst ipv4) timestamp(ts) PARTITION BY DAY"
  },
  {
    "query": "COPY (select * from market_data limit 3) TO 'market_data_parquet_table' WITH FORMAT PARQUET"
  },
  {
    "query": "COPY market_data TO 'market_data_parquet_table' WITH FORMAT PARQUET"
  },
  {
    "query": "SELECT * FROM 'sys.copy_export_log' WHERE id = '45ba24e5ba338099'"
  },
  {
    "query": "COPY '45ba24e5ba338099' CANCEL"
  },
  {
    "query": "COPY market_data TO 'market_data_parquet_table' WITH FORMAT PARQUET COMPRESSION_CODEC LZ4_RAW"
  },
  {
    "query": "ALTER TABLE trades CONVERT PARTITION TO PARQUET WHERE timestamp < '2025-08-31'"
  },
  {
    "query": "ALTER TABLE trades CONVERT PARTITION TO NATIVE WHERE timestamp < '2025-08-31'"
  },
  {
    "query": "select * from read_parquet('~/tmp/exp.parquet')"
  },
  {
    "query": "SELECT approx_count_distinct(symbol, 5) FROM trades"
  },
  {
    "query": "SELECT date, approx_count_distinct(user_id) FROM sessions GROUP BY date"
  },
  {
    "query": "SELECT region, approx_count_distinct(product_id) FROM sales GROUP BY region"
  },
  {
    "query": "SELECT approx_count_distinct(order_id, 8) FROM orders"
  },
  {
    "query": "SELECT store_id, approx_count_distinct(transaction_id) FROM transactions GROUP BY store_id"
  },
  {
    "query": "SELECT approx_percentile(price, 0.99) FROM trades"
  },
  {
    "query": "SELECT symbol, approx_median(price) FROM trades\nWHERE timestamp in today()\nGROUP BY symbol"
  },
  {
    "query": "SELECT symbol, approx_median(price, 3) FROM trades\nWHERE timestamp in today()\nGROUP BY symbol"
  },
  {
    "query": "SELECT arg_max(timestamp, price) AS peak_time FROM trades"
  },
  {
    "query": "SELECT symbol, arg_max(timestamp, price) AS ath_time\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT symbol, arg_max(order_id, amount) AS largest_order\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT arg_min(timestamp, price) AS bottom_time FROM trades"
  },
  {
    "query": "SELECT symbol, arg_min(timestamp, price) AS atl_time\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT arg_min(sensor_id, temperature) AS coldest_sensor\nFROM weather_data"
  },
  {
    "query": "SELECT avg(amount) FROM transactions"
  },
  {
    "query": "SELECT payment_type, avg(amount) FROM transactions"
  },
  {
    "query": "SELECT bit_and(flags) FROM events"
  },
  {
    "query": "SELECT category, bit_and(status_flags) FROM items"
  },
  {
    "query": "SELECT bit_or(permissions) FROM users"
  },
  {
    "query": "SELECT role, bit_or(permissions) FROM users"
  },
  {
    "query": "SELECT bit_xor(checksum) FROM data"
  },
  {
    "query": "SELECT partition_id, bit_xor(value) FROM records"
  },
  {
    "query": "SELECT bool_and(is_fulfilled) FROM orders"
  },
  {
    "query": "SELECT batch_id, bool_and(passed_qa) FROM items"
  },
  {
    "query": "SELECT symbol, bool_and(price > 100) FROM trades"
  },
  {
    "query": "SELECT bool_or(has_error) FROM orders"
  },
  {
    "query": "SELECT batch_id, bool_or(failed_qa) FROM items"
  },
  {
    "query": "SELECT symbol, bool_or(volume > 1000000) FROM trades"
  },
  {
    "query": "SELECT corr(price, quantity) FROM transactions"
  },
  {
    "query": "SELECT payment_type, corr(price, quantity) FROM transactions GROUP BY payment_type"
  },
  {
    "query": "SELECT count() FROM transactions"
  },
  {
    "query": "SELECT payment_type, count() FROM transactions"
  },
  {
    "query": "SELECT count(amount) FROM transactions"
  },
  {
    "query": "SELECT payment_type, count(amount) FROM transactions"
  },
  {
    "query": "SELECT count_distinct(side) FROM transactions"
  },
  {
    "query": "SELECT payment_type, count_distinct(counterparty) FROM transactions"
  },
  {
    "query": "SELECT covar_pop(price, quantity) FROM transactions"
  },
  {
    "query": "SELECT payment_type, covar_pop(price, quantity) FROM transactions GROUP BY payment_type"
  },
  {
    "query": "SELECT covar_samp(price, quantity) FROM transactions"
  },
  {
    "query": "SELECT payment_type, covar_samp(price, quantity) FROM transactions GROUP BY payment_type"
  },
  {
    "query": "SELECT first(symbol) FROM trades"
  },
  {
    "query": "SELECT first(symbol) FROM trades_unordered"
  },
  {
    "query": "SELECT first_not_null(symbol) FROM trades"
  },
  {
    "query": "SELECT first_not_null(symbol) FROM trades_unordered"
  },
  {
    "query": "SELECT geomean(growth_rate) FROM quarterly_data"
  },
  {
    "query": "SELECT asset, geomean(return_factor) FROM portfolio"
  },
  {
    "query": "SELECT avg(return_factor) AS arithmetic_mean,\n       geomean(return_factor) AS geometric_mean\nFROM investments"
  },
  {
    "query": "SELECT car_id, haversine_dist_deg(lat, lon, k)\nFROM rides"
  },
  {
    "query": "SELECT ksum(a)\nFROM (SELECT rnd_double() a FROM long_sequence(100))"
  },
  {
    "query": "SELECT last(symbol) FROM trades"
  },
  {
    "query": "SELECT last(symbol) FROM trades_unordered"
  },
  {
    "query": "SELECT last_not_null(symbol) FROM trades"
  },
  {
    "query": "SELECT last_not_null(symbol) FROM trades_unordered"
  },
  {
    "query": "SELECT max(amount) FROM transactions"
  },
  {
    "query": "SELECT payment_type, max(amount) FROM transactions"
  },
  {
    "query": "SELECT min(amount) FROM transactions"
  },
  {
    "query": "SELECT payment_type, min(amount) FROM transactions"
  },
  {
    "query": "SELECT symbol, mode(value) as mode FROM dataset"
  },
  {
    "query": "SELECT symbol, mode(side)\nFROM trades\nWHERE timestamp IN today()\nORDER BY symbol ASC"
  },
  {
    "query": "SELECT nsum(a)\nFROM (SELECT rnd_double() a FROM long_sequence(100))"
  },
  {
    "query": "SELECT stddev_samp(x)\nFROM (SELECT x FROM long_sequence(100))"
  },
  {
    "query": "SELECT stddev_pop(x)\nFROM (SELECT x FROM long_sequence(100))"
  },
  {
    "query": "SELECT string_agg(x::varchar, ',')\nFROM (SELECT x FROM long_sequence(5))"
  },
  {
    "query": "SELECT string_distinct_agg(symbol, ',') AS distinct_symbols\nFROM trades\nWHERE timestamp in today()"
  },
  {
    "query": "SELECT side, string_distinct_agg(symbol, ',') AS distinct_symbols\nFROM trades\nWHERE timestamp in today()"
  },
  {
    "query": "SELECT sum(quantity) FROM transactions"
  },
  {
    "query": "SELECT item, sum(quantity) FROM transactions"
  },
  {
    "query": "SELECT sum(cast(a AS LONG)) FROM my_table"
  },
  {
    "query": "SELECT var_samp(x)\nFROM (SELECT x FROM long_sequence(100))"
  },
  {
    "query": "SELECT var_pop(x)\nFROM (SELECT x FROM long_sequence(100))"
  },
  {
    "query": "SELECT weighted_avg(price, quantity) FROM transactions"
  },
  {
    "query": "SELECT weighted_stddev_freq(price_bucket, trade_count) FROM price_histogram"
  },
  {
    "query": "SELECT symbol, weighted_stddev_freq(price_bucket, trade_count)\nFROM trade_histogram\nGROUP BY symbol"
  },
  {
    "query": "SELECT weighted_stddev(price, volume) FROM trades"
  },
  {
    "query": "SELECT symbol, weighted_stddev(price, volume)\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT array_avg(ARRAY[ [1.0, 1.0], [2.0, 2.0] ])"
  },
  {
    "query": "SELECT\n  array_count(ARRAY[ [1.0, null], [null, 2.0] ]) c1,\n  array_count(ARRAY[ [0.0/0.0, 1.0/0.0], [-1.0/0.0, 0.0/0.0] ]) c2"
  },
  {
    "query": "SELECT array_cum_sum(ARRAY[ [1.0, 1.0], [2.0, 2.0] ])"
  },
  {
    "query": "SELECT array_max(ARRAY[ [1.0, 5.0], [3.0, 2.0] ])"
  },
  {
    "query": "SELECT array_min(ARRAY[ [1.0, 5.0], [3.0, 2.0] ])"
  },
  {
    "query": "SELECT\n  array_position(ARRAY[1.0, 2.0], 1.0) p1,\n  array_position(ARRAY[1.0, 2.0], 3.0) p2"
  },
  {
    "query": "SELECT array_sum(ARRAY[ [1.0, 1.0], [2.0, 2.0] ])"
  },
  {
    "query": "SELECT array_stddev(ARRAY[ [1.0, 2.0], [3.0, 4.0] ])"
  },
  {
    "query": "SELECT array_stddev_pop(ARRAY[ [1.0, 2.0], [3.0, 4.0] ])"
  },
  {
    "query": "SELECT array_stddev_samp(ARRAY[ [1.0, 2.0], [3.0, 4.0] ])"
  },
  {
    "query": "SELECT dim_length(ARRAY[42, 42], 1)"
  },
  {
    "query": "SELECT dot_product(\n  ARRAY[ [3.0, 4.0], [2.0, 5.0] ],\n  ARRAY[ [3.0, 4.0], [2.0, 5.0] ]\n)"
  },
  {
    "query": "SELECT flatten(ARRAY[[1, 2], [3, 4]])"
  },
  {
    "query": "SELECT\n  insertion_point(ARRAY[1.0, 2.0, 3.0], 2.5) i1,\n  insertion_point(ARRAY[1.0, 2.0, 3.0], 2.0) i2,\n  insertion_point(ARRAY[1.0, 2.0, 3.0], 2.0, true) i3"
  },
  {
    "query": "SELECT matmul(ARRAY[[1, 2], [3, 4]], ARRAY[[2, 3], [2, 3]])"
  },
  {
    "query": "SELECT shift(ARRAY[ [1.0, 2.0], [3.0, 4.0] ], 1)"
  },
  {
    "query": "SELECT shift(ARRAY[ [1.0, 2.0], [3.0, 4.0] ], -1)"
  },
  {
    "query": "SELECT shift(ARRAY[ [1.0, 2.0], [3.0, 4.0] ], -1, 10.0)"
  },
  {
    "query": "SELECT transpose(ARRAY[[1, 2], [3, 4]])"
  },
  {
    "query": "SELECT base64(rnd_bin(), 20)"
  },
  {
    "query": "SELECT isOrdered(numeric_sequence) is_num_ordered,\n       isOrdered(ts) is_ts_ordered\nFROM my_table"
  },
  {
    "query": "SELECT isOrdered(numeric_sequence) FROM my_table"
  },
  {
    "query": "SELECT timestamp,\n       coalesce(amount, 0) as amount_not_null\nFROM transactions"
  },
  {
    "query": "SELECT timestamp,\n       nullif(amount, 0) as amount_null_if_zero\nFROM transactions"
  },
  {
    "query": "-- Reduce precision\nSELECT CAST(ts_column AS DATE) FROM my_table"
  },
  {
    "query": "-- Increase precision\nSELECT CAST(date_column AS TIMESTAMP) FROM my_table"
  },
  {
    "query": "SELECT CAST(ts_column AS TIMESTAMP_NS) FROM my_table"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '$today'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '$now - 1h..$now'"
  },
  {
    "query": "SELECT dateadd('h', 2, ts) as shifted_time FROM trades"
  },
  {
    "query": "SELECT year(ts), month(ts) FROM trades"
  },
  {
    "query": "SELECT date_trunc('hour', '2022-03-11T22:00:30.555555Z') hour,\ndate_trunc('month', '2022-03-11T22:00:30.555555Z') month,\ndate_trunc('year','2022-03-11T22:00:30.555555Z') year,\ndate_trunc('year','2022-03-11T22:00:30.555555555Z') year2"
  },
  {
    "query": "SELECT systimestamp(), dateadd('h', 2, systimestamp())\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT systimestamp(), dateadd('d', 2, systimestamp())\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT\n    '2024-10-21T10:00:00Z',\n    dateadd('w', 1, '2024-10-21T10:00:00Z', 'Europe/Bratislava') as with_tz,\n    dateadd('w', 1, '2024-10-21T10:00:00Z') as without_tz\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT systimestamp(), dateadd('M', 2, systimestamp())\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT datediff('d', '2020-01-23', '2020-01-27')"
  },
  {
    "query": "SELECT datediff('M', '2020-01-23', '2020-02-27')"
  },
  {
    "query": "SELECT day(to_timestamp('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM trades\nLIMIT -1"
  },
  {
    "query": "SELECT day(ts), count() FROM transactions"
  },
  {
    "query": "SELECT to_str(ts,'EE'),day_of_week(ts) FROM myTable"
  },
  {
    "query": "SELECT to_str(ts,'EE'),day_of_week_sunday_first(ts) FROM myTable"
  },
  {
    "query": "SELECT month(ts), days_in_month(ts) FROM myTable"
  },
  {
    "query": "SELECT extract(millennium from '2023-03-11T22:00:30.555555Z') millennium,\nextract(year from '2023-03-11T22:00:30.555555Z') year,\nextract(month from '2023-03-11T22:00:30.555555Z') month,\nextract(week from '2023-03-11T22:00:30.555555Z') week,\nextract(hour from '2023-03-11T22:00:30.555555Z') hour,\nextract(second from '2023-03-11T22:00:30.555555Z') second"
  },
  {
    "query": "SELECT hour(to_timestamp('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT hour(ts), count() FROM transactions"
  },
  {
    "query": "SELECT interval('2024-10-08T11:09:47.573Z', '2024-10-09T11:09:47.573Z')"
  },
  {
    "query": "SELECT\n  interval_start(\n    interval('2024-10-08T11:09:47.573Z', '2024-10-09T11:09:47.573Z')\n  )"
  },
  {
    "query": "SELECT\n  interval_end(\n    interval('2024-10-08T11:09:47.573Z', '2024-10-09T11:09:47.573Z')\n  )"
  },
  {
    "query": "SELECT year(timestamp), is_leap_year(timestamp)\nFROM trades\nlimit -1"
  },
  {
    "query": "SELECT micros(to_timestamp('2020-03-01:15:43:21.123456', 'yyyy-MM-dd:HH:mm:ss.SSSUUU'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT micros(to_timestamp('2020-03-01:15:43:21.123456', 'yyyy-MM-dd:HH:mm:ss.SSSU'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT micros(ts), count() FROM transactions"
  },
  {
    "query": "SELECT millis(\n    to_timestamp('2020-03-01:15:43:21.123456', 'yyyy-MM-dd:HH:mm:ss.SSSUUU'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT millis(to_timestamp('2020-03-01:15:43:21.123', 'yyyy-MM-dd:HH:mm:ss.S'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT millis(ts), count() FROM transactions"
  },
  {
    "query": "SELECT minute(to_timestamp('2022-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM trades\nLIMIT -1"
  },
  {
    "query": "SELECT minute(ts), count() FROM transactions"
  },
  {
    "query": "SELECT month(to_timestamp('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT month(ts), count() FROM transactions"
  },
  {
    "query": "SELECT nanos(\n    to_timestamp_ns('2020-03-01:15:43:21.123456789', 'yyyy-MM-dd:HH:mm:ss.SSSUUUNNN')) as nanos\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT created, origin FROM telemetry\nWHERE created > dateadd('d', -1, now())"
  },
  {
    "query": "SELECT now() FROM long_sequence(3)"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp > now() - 60000000L"
  },
  {
    "query": "SELECT now_ns() FROM long_sequence(3)"
  },
  {
    "query": "SELECT pg_postmaster_start_time()"
  },
  {
    "query": "SELECT second(to_timestamp('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT second(ts), count() FROM transactions"
  },
  {
    "query": "SELECT true as in_today FROM long_sequence(1)\nWHERE now() IN today()"
  },
  {
    "query": "SELECT today() as today, today('CEST') as adjusted"
  },
  {
    "query": "INSERT INTO readings\nVALUES(sysdate(), 123.5)"
  },
  {
    "query": "SELECT * FROM trades\nWHERE timestamp > sysdate() - 60000000L"
  },
  {
    "query": "INSERT INTO readings\nVALUES(systimestamp(), 123.5)"
  },
  {
    "query": "INSERT INTO readings\nVALUES(systimestamp_ns(), 123.5)"
  },
  {
    "query": "WITH t AS (SELECT cast('2016-02-10T16:18:22.862145333Z' AS timestamp_ns) ts)\nSELECT\n  ts,\n  timestamp_ceil('n', ts) c_nano,\n  timestamp_ceil('U', ts) c_micro,\n  timestamp_ceil('T', ts) c_milli,\n  timestamp_ceil('s', ts) c_second,\n  timestamp_ceil('m', ts) c_minute,\n  timestamp_ceil('h', ts) c_hour,\n  timestamp_ceil('d', ts) c_day,\n  timestamp_ceil('M', ts) c_month,\n  timestamp_ceil('y', ts) c_year\n  FROM t"
  },
  {
    "query": "SELECT timestamp_floor('5d', '2018-01-01')"
  },
  {
    "query": "WITH t AS (SELECT cast('2016-02-10T16:18:22.862145333Z' AS timestamp_ns) ts)\nSELECT\n  ts,\n  timestamp_floor('n', ts) c_nano,\n  timestamp_floor('U', ts) c_micro,\n  timestamp_floor('T', ts) c_milli,\n  timestamp_floor('s', ts) c_second,\n  timestamp_floor('m', ts) c_minute,\n  timestamp_floor('h', ts) c_hour,\n  timestamp_floor('d', ts) c_day,\n  timestamp_floor('M', ts) c_month,\n  timestamp_floor('y', ts) c_year\n  FROM t"
  },
  {
    "query": "SELECT timestamp_floor('5d', '2018-01-01', '2018-01-01')"
  },
  {
    "query": "SELECT timestamp_floor('5d', timestamp, '2018') t, count\nFROM trades\nWHERE timestamp in '2018'\nORDER BY 1"
  },
  {
    "query": "SELECT timestamp_shuffle('2023-03-31T22:00:30.555998Z', '2023-04-01T22:00:30.555998Z')"
  },
  {
    "query": "SELECT to_date('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss')\nFROM trades"
  },
  {
    "query": "SELECT to_date('2020-03-01:15:43:21', 'yyyy')\nFROM long_sequence(1)"
  },
  {
    "query": "INSERT INTO measurements\nvalues(to_date('2019-12-12T12:15', 'yyyy-MM-ddTHH:mm'), 123.5)"
  },
  {
    "query": "SELECT to_str(systimestamp(), 'yyyy-MM-dd') FROM long_sequence(1)"
  },
  {
    "query": "SELECT to_str(systimestamp(), 'yyyy-MM-dd gooD DAY 123') FROM long_sequence(1)"
  },
  {
    "query": "SELECT to_timestamp('2020-03-01:15:43:21.127329', 'yyyy-MM-dd:HH:mm:ss.SSSUUU')\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT to_timestamp('2020-03-01:15:43:00.000000001Z', 'yyyy-MM-dd:HH:mm:ss.SSSUUUNNNZ')\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT to_timestamp('2020-03-01:15:43:21', 'yyyy')\nFROM long_sequence(1)"
  },
  {
    "query": "INSERT INTO measurements\nvalues(to_timestamp('2019-12-12T12:15', 'yyyy-MM-ddTHH:mm'), 123.5)"
  },
  {
    "query": "SELECT to_timestamp_ns('2020-03-01:15:43:21.127329512', 'yyyy-MM-dd:HH:mm:ss.SSSUUUNNN') as timestamp_ns\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT to_timezone(1623167145000000, 'Europe/Berlin')"
  },
  {
    "query": "SELECT to_timezone(1623167145000000, '-08:00')"
  },
  {
    "query": "SELECT to_timezone('2021-06-08T13:45:45.000000Z', 'PST')"
  },
  {
    "query": "SELECT to_utc(1623167145000000, 'Europe/Berlin')"
  },
  {
    "query": "SELECT to_utc(1623167145000000, '-08:00')"
  },
  {
    "query": "SELECT to_utc('2021-06-08T13:45:45.000000Z', 'PST')"
  },
  {
    "query": "SELECT week_of_year('2023-03-31T22:00:30.555998Z')"
  },
  {
    "query": "SELECT year(to_timestamp('2020-03-01:15:43:21', 'yyyy-MM-dd:HH:mm:ss'))\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT year(ts), count() FROM transactions"
  },
  {
    "query": "SELECT\n  to_timestamp('2024-03-15T14:30:45.123456Z', 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ') as iso,\n  to_timestamp('2024-03-15 14:30:45', 'yyyy-MM-dd HH:mm:ss') as standard,\n  to_timestamp('15/03/2024 14:30:45', 'dd/MM/yyyy HH:mm:ss') as european\nFROM long_sequence(1)"
  },
  {
    "query": "select l2price(50, ARRAY[14.0, 16.0, 23.0, 12.0], ARRAY[14.50, 14.60, 14.80, 15.10])"
  },
  {
    "query": "select l2price(50, 14, 14.50, 16, 14.60, 23, 14.80, 12, 15.10)"
  },
  {
    "query": "CREATE TABLE order_book (\n  ts TIMESTAMP,\n  bidSize DOUBLE[], bid DOUBLE[],\n  askSize DOUBLE[], ask DOUBLE[]\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO order_book VALUES\n  ('2024-05-22T09:40:15.006000Z',\n    ARRAY[40.0, 47.0, 39.0], ARRAY[14.10, 14.00, 13.90],\n    ARRAY[54.0, 36.0, 23.0], ARRAY[14.50, 14.60, 14.80]),\n  ('2024-05-22T09:40:15.175000Z',\n    ARRAY[42.0, 45.0, 35.0], ARRAY[14.00, 13.90, 13.80],\n    ARRAY[16.0, 57.0, 30.0], ARRAY[14.30, 14.50, 14.60]),\n  ('2024-05-22T09:40:15.522000Z',\n    ARRAY[36.0, 38.0, 31.0], ARRAY[14.10, 14.00, 13.90],\n    ARRAY[30.0, 47.0, 34.0], ARRAY[14.40, 14.50, 14.60])"
  },
  {
    "query": "SELECT ts, L2PRICE(100, askSize, ask) AS buy FROM order_book"
  },
  {
    "query": "SELECT ts, L2PRICE(100, bidSize, bid) AS sell FROM order_book"
  },
  {
    "query": "SELECT ts, L2PRICE(100, askSize, ask) - L2PRICE(100, bidSize, bid) AS spread FROM order_book"
  },
  {
    "query": "CREATE TABLE order_book (\n  ts TIMESTAMP,\n  bidSize1 DOUBLE, bid1 DOUBLE, bidSize2 DOUBLE, bid2 DOUBLE, bidSize3 DOUBLE, bid3 DOUBLE,\n  askSize1 DOUBLE, ask1 DOUBLE, askSize2 DOUBLE, ask2 DOUBLE, askSize3 DOUBLE, ask3 DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO order_book VALUES\n  ('2024-05-22T09:40:15.006000Z', 40, 14.10, 47, 14.00, 39, 13.90, 54, 14.50, 36, 14.60, 23, 14.80),\n  ('2024-05-22T09:40:15.175000Z', 42, 14.00, 45, 13.90, 35, 13.80, 16, 14.30, 57, 14.50, 30, 14.60),\n  ('2024-05-22T09:40:15.522000Z', 36, 14.10, 38, 14.00, 31, 13.90, 30, 14.40, 47, 14.50, 34, 14.60)"
  },
  {
    "query": "SELECT ts, L2PRICE(100, askSize1, ask1, askSize2, ask2, askSize3, ask3) AS buy FROM order_book"
  },
  {
    "query": "SELECT ts, L2PRICE(100, bidSize1, bid1, bidSize2, bid2, bidSize3, bid3) AS sell FROM order_book"
  },
  {
    "query": "SELECT ts, L2PRICE(100, askSize1, ask1, askSize2, ask2, askSize3, ask3)\n  - L2PRICE(100, bidSize1, bid1, bidSize2, bid2, bidSize3, bid3) AS spread FROM order_book"
  },
  {
    "query": "SELECT mid(1.5760, 1.5763)"
  },
  {
    "query": "SELECT regr_intercept(y, x) AS y_intercept FROM measurements"
  },
  {
    "query": "SELECT category, regr_intercept(sales, advertising_spend) AS base_sales\nFROM sales_data\nGROUP BY category"
  },
  {
    "query": "SELECT regr_intercept(y, x) AS y_intercept\nFROM (\n    SELECT 1 AS x, 2 AS y\n    UNION ALL SELECT 2, NULL\n    UNION ALL SELECT NULL, 4\n    UNION ALL SELECT 4, 5\n)"
  },
  {
    "query": "SELECT regr_slope(y, x) AS slope FROM measurements"
  },
  {
    "query": "SELECT category, regr_slope(sales, advertising_spend) AS slope FROM sales_data\nGROUP BY category"
  },
  {
    "query": "SELECT regr_slope(stock_return, market_return) AS beta FROM stock_returns"
  },
  {
    "query": "SELECT spread_bps(1.5760, 1.5763)"
  },
  {
    "query": "SELECT wmid(100, 5, 6, 100)"
  },
  {
    "query": "SELECT md5('abc')"
  },
  {
    "query": "SELECT md5('')"
  },
  {
    "query": "SELECT md5('Hello, world!')"
  },
  {
    "query": "SELECT sha1('abc')"
  },
  {
    "query": "SELECT sha1('')"
  },
  {
    "query": "SELECT sha1('Hello, world!')"
  },
  {
    "query": "SELECT sha256('abc')"
  },
  {
    "query": "SELECT sha256('')"
  },
  {
    "query": "SELECT sha256('Hello, world!')"
  },
  {
    "query": "SELECT \n    filename,\n    sha256(content) = expected_hash as is_valid\nFROM files"
  },
  {
    "query": "SELECT \n    md5(email) as hashed_email,\n    count(*) as user_count\nFROM users\nGROUP BY hashed_email"
  },
  {
    "query": "SELECT \n    file_id,\n    sha1(binary_content) as content_hash\nFROM binary_files"
  },
  {
    "query": "SELECT\n    json_extract(trade_details, '$.quantity')::long quantity,\n    json_extract(trade_details, '$.price')::double price,\n    json_extract(trade_details, '$.executions[0].timestamp')::timestamp first_ex_ts\nFROM\n    trades\nWHERE\n    json_extract(trade_details, '$.exchange') = 'NASDAQ'"
  },
  {
    "query": "SELECT\n    cast(json_extract('[0.25, 0.5, 1.0]', '$[0]') as float) a\nFROM\n    long_sequence(1)"
  },
  {
    "query": "-- Add two columns for caching.\nALTER TABLE trades ADD COLUMN quantity long"
  },
  {
    "query": "ALTER TABLE trades ADD COLUMN price double"
  },
  {
    "query": "-- Populate the columns from the existing JSON document.\nUPDATE trades SET quantity = json_extract(trade_details, '$.quantity')::long"
  },
  {
    "query": "UPDATE trades SET price = json_extract(trade_details, '$.price')::double"
  },
  {
    "query": "INSERT INTO trades_summary SELECT\n    json_extract(trade_details, '$.quantity')::long as quantity,\n    json_extract(trade_details, '$.price')::double as price,\n    timestamp\nFROM trades"
  },
  {
    "query": "SELECT build()"
  },
  {
    "query": "functions()",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM query_activity()"
  },
  {
    "query": "memory_metrics()",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM reader_pool()"
  },
  {
    "query": "SELECT * FROM writer_pool()"
  },
  {
    "query": "SELECT current_database()"
  },
  {
    "query": "SELECT current_schema()"
  },
  {
    "query": "SELECT current_user()"
  },
  {
    "query": "tables()",
    "skipAutocomplete": true
  },
  {
    "query": "tables() WHERE partitionBy = 'DAY'",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT table_name, table_row_count, table_last_write_timestamp\nFROM tables()\nWHERE table_last_write_timestamp IS NOT NULL\nORDER BY table_last_write_timestamp DESC\nLIMIT 10"
  },
  {
    "query": "SELECT table_name, table_min_timestamp, table_max_timestamp\nFROM tables()\nWHERE table_max_timestamp IS NOT NULL\nORDER BY table_max_timestamp DESC\nLIMIT 10"
  },
  {
    "query": "SELECT\n    table_name,\n    wal_txn - table_txn AS pending_txns,\n    wal_pending_row_count\nFROM tables()\nWHERE walEnabled\n  AND wal_txn IS NOT NULL\n  AND wal_txn > table_txn\nORDER BY pending_txns DESC"
  },
  {
    "query": "SELECT table_name, table_suspended, table_memory_pressure_level\nFROM tables()\nWHERE walEnabled AND table_suspended"
  },
  {
    "query": "SELECT table_name, table_memory_pressure_level\nFROM tables()\nWHERE table_memory_pressure_level > 0\nORDER BY table_memory_pressure_level DESC"
  },
  {
    "query": "SELECT table_name, wal_dedup_row_count_since_start, wal_tx_count,\n       wal_dedup_row_count_since_start * 100.0 / NULLIF(wal_tx_count, 0) AS dedup_ratio\nFROM tables()\nWHERE wal_dedup_row_count_since_start > 0\nORDER BY wal_dedup_row_count_since_start DESC"
  },
  {
    "query": "SELECT table_name, wal_tx_count, wal_tx_size_p50, wal_tx_size_p99, wal_tx_size_max\nFROM tables()\nWHERE walEnabled AND wal_tx_count > 0\nORDER BY wal_tx_size_p99 DESC"
  },
  {
    "query": "SELECT table_name, wal_tx_size_p50, wal_tx_size_max,\n       wal_tx_size_max / NULLIF(wal_tx_size_p50, 0) AS spike_ratio\nFROM tables()\nWHERE walEnabled AND wal_tx_size_max > wal_tx_size_p50 * 10"
  },
  {
    "query": "SELECT table_name,\n       table_write_amp_count,\n       table_write_amp_p50,\n       table_write_amp_p99,\n       table_write_amp_max\nFROM tables()\nWHERE walEnabled\n  AND table_write_amp_p50 > 2.0\nORDER BY table_write_amp_p99 DESC"
  },
  {
    "query": "SELECT table_name,\n       table_merge_rate_p99 AS slowest_throughput,\n       table_merge_rate_p50 AS median_throughput,\n       table_merge_rate_max AS best_throughput\nFROM tables()\nWHERE walEnabled\n  AND table_merge_rate_count > 0\nORDER BY table_merge_rate_p99 ASC"
  },
  {
    "query": "SELECT table_name, replica_batch_count, replica_batch_size_p50,\n       replica_batch_size_p90, replica_batch_size_max, replica_more_pending\nFROM tables()\nWHERE replica_batch_count > 0\nORDER BY replica_batch_count DESC"
  },
  {
    "query": "SELECT table_name,\n       partitionBy,\n       walEnabled,\n       dedup,\n       maxUncommittedRows,\n       o3MaxLag / 1000000 AS o3MaxLagSeconds\nFROM tables()\nWHERE walEnabled\nORDER BY table_name"
  },
  {
    "query": "SELECT * FROM table_storage()"
  },
  {
    "query": "SELECT tableName, rowCount, diskSize\nFROM table_storage()\nWHERE walEnabled = true"
  },
  {
    "query": "SELECT tableName, partitionCount, rowCount\nFROM table_storage()\nWHERE partitionBy = 'HOUR'"
  },
  {
    "query": "wal_tables()",
    "skipAutocomplete": true
  },
  {
    "query": "table_columns('my_table')",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT \"column\", type, designated FROM table_columns('my_table') WHERE designated = true"
  },
  {
    "query": "SELECT type, count() FROM table_columns('my_table')"
  },
  {
    "query": "CREATE TABLE my_table AS (\n    SELECT\n        rnd_symbol('EURO', 'USD', 'OTHER') symbol,\n        rnd_double() * 50.0 price,\n        rnd_double() * 20.0 amount,\n        to_timestamp('2023-01-01', 'yyyy-MM-dd') + x * 6 * 3600 * 100000L timestamp\n    FROM long_sequence(700)\n), INDEX(symbol capacity 32) TIMESTAMP(timestamp) PARTITION BY WEEK"
  },
  {
    "query": "table_partitions('my_table')",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT size_pretty(sum(diskSize)) FROM table_partitions('my_table')"
  },
  {
    "query": "SELECT * FROM table_partitions('my_table') WHERE active = true"
  },
  {
    "query": "materialized_views()",
    "skipAutocomplete": true
  },
  {
    "query": "views()",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT view_name, invalidation_reason\nFROM views()\nWHERE view_status = 'invalid'"
  },
  {
    "query": "SELECT * FROM views() ORDER BY view_name"
  },
  {
    "query": "SELECT version()"
  },
  {
    "query": "SELECT pg_catalog.version()"
  },
  {
    "query": "SELECT flush_query_cache()"
  },
  {
    "query": "SELECT\n    x - 2 a,\n    abs(x -2)\nFROM long_sequence(3)"
  },
  {
    "query": "SELECT ceil(15.75) as RoundedUp"
  },
  {
    "query": "SELECT exp(2) as Exponent"
  },
  {
    "query": "SELECT floor(15.75) as RoundedDown"
  },
  {
    "query": "SELECT greatest(11, 3, 8, 15)"
  },
  {
    "query": "SELECT least(11, 3, 8, 15)"
  },
  {
    "query": "SELECT ln(4.123)"
  },
  {
    "query": "SELECT log(100)"
  },
  {
    "query": "SELECT power(2, 3)"
  },
  {
    "query": "SELECT\n    d,\n    round(d, -2),\n    round(d, -1),\n    round(d,0),\n    round(d,1),\n    round(d,2)\nFROM dbl"
  },
  {
    "query": "SELECT\n    d,\n    round_down(d, -2),\n    round_down(d, -1),\n    round_down(d,0),\n    round_down(d,1),\n    round_down(d,2)\nFROM dbl"
  },
  {
    "query": "SELECT\n    round_half_even(5.55, 1),\n    round_half_even(5.65, 1)\nFROM long_sequence(1)"
  },
  {
    "query": "SELECT\n    d,\n    round_half_even(d, -2),\n    round_half_even(d, -1),\n    round_half_even(d,0),\n    round_half_even(d,1),\n    round_half_even(d,2)\nFROM dbl"
  },
  {
    "query": "SELECT\n    d,\n    round_up(d, -2),\n    round_up(d, -1),\n    round_up(d,0),\n    round_up(d,1),\n    round_up(d,2)\nFROM dbl"
  },
  {
    "query": "SELECT x-3 arg, sign(x-3) from long_sequence(5)"
  },
  {
    "query": "SELECT size_pretty(400032)"
  },
  {
    "query": "SELECT sqrt(4000.32)"
  },
  {
    "query": "SELECT * FROM read_parquet('trades.parquet')\nWHERE side = 'buy'\nLIMIT 1"
  },
  {
    "query": "SELECT * FROM read_parquet('/var/lib/questdb/import/trades.parquet')"
  },
  {
    "query": "SELECT t.symbol, t.price, r.label\nFROM read_parquet('trades.parquet') t\nJOIN ref_data r ON t.symbol = r.symbol",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT 'quest' LIKE 'quest'"
  },
  {
    "query": "SELECT 'quest' LIKE 'ques_'"
  },
  {
    "query": "SELECT 'quest' LIKE 'que%'"
  },
  {
    "query": "SELECT 'quest' LIKE '_ues_'"
  },
  {
    "query": "SELECT 'quest' LIKE 'q_'\n-- Returns false"
  },
  {
    "query": "SELECT 'quest' ILIKE 'QUEST'"
  },
  {
    "query": "SELECT 'qUeSt' ILIKE 'QUEST'"
  },
  {
    "query": "SELECT 'quest' ILIKE 'QUE%'"
  },
  {
    "query": "SELECT 'QUEST' ILIKE '_ues_'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE symbol LIKE '%-USDT'\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "SELECT * FROM trades\nWHERE symbol ILIKE '%-usdt'\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "SELECT regexp_replace('MYSQL is a great database', '^(\\S*)', 'QuestDB')"
  },
  {
    "query": "SELECT\n    timestamp_sequence('2024-01-01', 100000L) AS ts,\n    rnd_symbol('AAPL', 'GOOGL', 'MSFT', 'AMZN') AS ticker,\n    rnd_symbol('BUY', 'SELL') AS side,\n    rnd_double() * 1000 AS price,\n    rnd_int(1, 10000, 0) AS quantity\nFROM long_sequence(1000000)"
  },
  {
    "query": "SELECT val FROM (\n    SELECT rnd_int(1, 100, 0) AS val FROM long_sequence(10)\n) WHERE val > 50"
  },
  {
    "query": "CREATE TABLE test AS (\n    SELECT\n        timestamp_sequence('2024-01-01', 100000L) AS ts,\n        rnd_int(1, 100, 0) AS val\n    FROM long_sequence(10)\n) TIMESTAMP(ts)"
  },
  {
    "query": "SELECT * FROM test WHERE val > 50"
  },
  {
    "query": "SELECT\n    value a,\n    count() b\nFROM (SELECT rnd_boolean() value FROM long_sequence(100))"
  },
  {
    "query": "SELECT rnd_byte() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_byte(-1,1) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_short() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_short(-1,1) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_int() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_int(1,4,0) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_int(1,4,1) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_int(1,4,2) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_long() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_long(1,4,0) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_long(1,4,1) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_long(-10000000,10000000,2) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_long256() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_float() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_float(2) FROM long_sequence(6)"
  },
  {
    "query": "SELECT rnd_double() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_double(2) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_date(\n    to_date('2015', 'yyyy'),\n    to_date('2016', 'yyyy'),\n    0)\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_timestamp(\n    to_timestamp('2015', 'yyyy'),\n    to_timestamp('2016', 'yyyy'),\n    0)\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_char() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_symbol('ABC','def', '123')\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_symbol(2, 3, 4, 0)\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_symbol_zipf('AAPL', 'MSFT', 'GOOGL', 'TSLA', 'AMZN', 2.0) AS ticker\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT\n    ticker,\n    count() AS cnt\nFROM (\n    SELECT rnd_symbol_zipf('AAPL', 'MSFT', 'GOOGL', 'TSLA', 'AMZN', 2.0) AS ticker\n    FROM long_sequence(100000)\n)\nGROUP BY ticker\nORDER BY cnt DESC"
  },
  {
    "query": "SELECT rnd_symbol_zipf(1000, 1.5) AS sym\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_symbol_weighted('AAPL', 50, 'MSFT', 30, 'GOOGL', 15, 'TSLA', 5) AS ticker\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT\n    ticker,\n    count() AS cnt\nFROM (\n    SELECT rnd_symbol_weighted('AAPL', 50, 'MSFT', 30, 'GOOGL', 15, 'TSLA', 5) AS ticker\n    FROM long_sequence(100000)\n)\nGROUP BY ticker\nORDER BY cnt DESC"
  },
  {
    "query": "SELECT rnd_varchar('ABC','def', '123')\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_varchar(2, 2, 4)\nFROM long_sequence(4)"
  },
  {
    "query": "SELECT rnd_str('ABC','def', '123')\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_str(2, 2, 4)\nFROM long_sequence(8)"
  },
  {
    "query": "SELECT rnd_str(3, 2, 2, 0) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_bin() FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_bin(2, 5, 2) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_uuid4() FROM long_sequence(3)"
  },
  {
    "query": "SELECT rnd_ipv4() FROM long_sequence(3)"
  },
  {
    "query": "SELECT rnd_ipv4('22.43.0.0/16', 0) FROM long_sequence(3)"
  },
  {
    "query": "SELECT rnd_double_array(2, 2, 2)"
  },
  {
    "query": "SELECT rnd_double_array(2, 0, 0, 2, 5)"
  },
  {
    "query": "SELECT rnd_decimal(8, 2, 0) FROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_decimal(8, 2, 4) FROM long_sequence(5)"
  },
  {
    "query": "SELECT x, rnd_double()\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT x, x * x AS square\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT rnd_double()\nFROM long_sequence(2, 128349234, 4327897)"
  },
  {
    "query": "generate_series(-3, 3)",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series(3, -3, -1)",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series(-3d, 3d)",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series(3d, -3d, -1.5d)",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series('2025-01-01', '2025-02-01', '5d')",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series('2025-01-01', '2025-02-01', '-5d')",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series(\n    '2025-01-01T00:00:00Z'::timestamp,\n    '2025-01-01T00:05:00Z'::timestamp,\n    60_000_000 -- 1 minute in microseconds\n)",
    "skipAutocomplete": true
  },
  {
    "query": "generate_series(\n    to_timestamp_ns('2025-01-01T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),\n    '2025-01-01T00:00:00.000001',\n    '500n'\n)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT x, timestamp_sequence(\n    to_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),\n    100000L -- 100ms in microseconds\n) AS ts\nFROM long_sequence(5)"
  },
  {
    "query": "SELECT x, timestamp_sequence(\n    to_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),\n    rnd_short(1, 5) * 100000L -- 100-500ms random intervals\n) AS ts\nFROM long_sequence(5)"
  },
  {
    "query": "CREATE TABLE lidar_scans (\n  ts TIMESTAMP,\n  robot_id SYMBOL,\n  pose_x DOUBLE,\n  pose_y DOUBLE,\n  point_count INT,\n  scan VARCHAR -- reference to scan data, e.g. 's3://my-bucket/lidar/scan_001.laz'\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO lidar_scans VALUES\n  ('2024-01-15T09:00:00Z', 'robot-1', 12.5, 8.3, 0.5, 48000, 's3://warehouse/scan_001.laz'),\n  ('2024-01-15T09:00:05Z', 'robot-1', 15.2, 10.1, 0.5, 52000, 's3://warehouse/scan_002.laz'),\n  ('2024-01-15T09:00:10Z', 'robot-1', 18.7, 12.8, 0.5, 45000, 's3://warehouse/scan_003.laz'),\n  ('2024-01-15T09:00:15Z', 'robot-1', 45.3, 30.2, 0.5, 51000, 's3://warehouse/scan_004.laz'),\n  ('2024-01-15T09:00:20Z', 'robot-1', 48.9, 32.5, 0.5, 49000, 's3://warehouse/scan_005.laz')"
  },
  {
    "query": "SELECT ts, robot_id, pose_x, pose_y, scan\nFROM lidar_scans\nWHERE within_box(pose_x, pose_y, 10.0, 5.0, 20.0, 15.0)"
  },
  {
    "query": "CREATE TABLE zones (\n  zone_name SYMBOL,\n  min_x DOUBLE,\n  min_y DOUBLE,\n  max_x DOUBLE,\n  max_y DOUBLE\n)"
  },
  {
    "query": "INSERT INTO zones VALUES\n  ('loading_dock', 0, 0, 25, 20),\n  ('storage_area', 40, 25, 60, 45)"
  },
  {
    "query": "SELECT s.ts, s.robot_id, s.scan\nFROM lidar_scans s\nJOIN zones z ON within_box(s.pose_x, s.pose_y, z.min_x, z.min_y, z.max_x, z.max_y)\nWHERE z.zone_name = 'loading_dock'"
  },
  {
    "query": "SELECT ts, robot_id, pose_x, pose_y, scan\nFROM lidar_scans\nWHERE within_radius(pose_x, pose_y, 15.0, 10.0, 10.0)"
  },
  {
    "query": "CREATE TABLE zones_circular (\n  zone_name SYMBOL,\n  center_x DOUBLE,\n  center_y DOUBLE,\n  radius DOUBLE\n)"
  },
  {
    "query": "INSERT INTO zones_circular VALUES\n  ('workstation_A', 15.0, 10.0, 8.0),\n  ('workstation_B', 47.0, 31.0, 5.0)"
  },
  {
    "query": "SELECT s.ts, s.robot_id, s.scan\nFROM lidar_scans s\nJOIN zones_circular z ON within_radius(s.pose_x, s.pose_y, z.center_x, z.center_y, z.radius)\nWHERE z.zone_name = 'workstation_A'"
  },
  {
    "query": "CREATE TABLE vehicle_positions (\n  ts TIMESTAMP,\n  vehicle_id SYMBOL,\n  lat DOUBLE,\n  lon DOUBLE,\n  speed DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "INSERT INTO vehicle_positions VALUES\n  ('2024-01-15T10:00:00Z', 'truck-1', 51.5074, -0.1278, 0),\n  ('2024-01-15T10:00:05Z', 'truck-1', 51.5095, -0.1245, 25),\n  ('2024-01-15T10:00:10Z', 'truck-1', 51.5120, -0.1190, 30),\n  ('2024-01-15T10:00:15Z', 'truck-1', 51.5280, -0.1020, 35),\n  ('2024-01-15T10:00:20Z', 'truck-1', 51.5350, -0.0890, 40)"
  },
  {
    "query": "SELECT ts, vehicle_id, lat, lon\nFROM vehicle_positions\nWHERE geo_within_radius_latlon(lat, lon, 51.5074, -0.1278, 500)"
  },
  {
    "query": "CREATE TABLE service_areas (\n  area_name SYMBOL,\n  center_lat DOUBLE,\n  center_lon DOUBLE,\n  radius_m DOUBLE\n)"
  },
  {
    "query": "INSERT INTO service_areas VALUES\n  ('central_london', 51.5074, -0.1278, 1000),\n  ('kings_cross', 51.5320, -0.1240, 800)"
  },
  {
    "query": "SELECT v.ts, v.vehicle_id, v.lat, v.lon\nFROM vehicle_positions v\nJOIN service_areas a ON geo_within_radius_latlon(v.lat, v.lon, a.center_lat, a.center_lon, a.radius_m)\nWHERE a.area_name = 'central_london'"
  },
  {
    "query": "SELECT\n    ts,\n    vehicle_id,\n    round(geo_distance_meters(lat, lon, 51.5074, -0.1278), 0) AS distance_from_depot_m\nFROM vehicle_positions"
  },
  {
    "query": "CREATE TABLE depots (\n  depot_name SYMBOL,\n  lat DOUBLE,\n  lon DOUBLE\n)"
  },
  {
    "query": "INSERT INTO depots VALUES\n  ('west_depot', 51.5074, -0.1278),\n  ('east_depot', 51.5300, -0.0700)"
  },
  {
    "query": "SELECT\n    v.ts,\n    v.vehicle_id,\n    round(geo_distance_meters(v.lat, v.lon, d.lat, d.lon), 0) AS distance_m\nFROM vehicle_positions v\nJOIN depots d ON d.depot_name = 'east_depot'"
  },
  {
    "query": "SELECT\n    rnd_geohash(7) AS g7,\n    rnd_geohash(10) AS g10,\n    rnd_geohash(30) AS g30,\n    rnd_geohash(60) AS g60\nFROM long_sequence(3)"
  },
  {
    "query": "SELECT\n    location_name,\n    make_geohash(lon, lat, 30) AS geohash\nFROM locations"
  },
  {
    "query": "SELECT firstName, lastName, concat(firstName, ' ', lastName) FROM names"
  },
  {
    "query": "SELECT\nconcat(\n    'trades,instrument=', rnd_str(2,2,0),\n    ',side=', rnd_str('B', 'S'),\n    ' price=', abs(cast(rnd_double(0)*100000 AS INT)),\n    ',quantity=', abs(cast(rnd_double(0)*10000 AS INT)),\n    ' ',\n    1571270400000 + (x-1) * 100\n)\nFROM long_sequence(5) x"
  },
  {
    "query": "SELECT name a, length(name) b FROM names limit 4"
  },
  {
    "query": "SELECT name a, length_bytes(name) b FROM names limit 4"
  },
  {
    "query": "SELECT name, left('Thompson', 3) l FROM names LIMIT 3"
  },
  {
    "query": "SELECT name, right('Thompson', 2) r FROM names LIMIT 3"
  },
  {
    "query": "SELECT lpad('QuestDB', 10, '0') AS padded_string"
  },
  {
    "query": "SELECT ltrim('   QuestDB   ') AS trimmed_string"
  },
  {
    "query": "SELECT trim('   QuestDB   ') AS trimmed_string"
  },
  {
    "query": "SELECT string_agg(symbol, ',') as symbols\nFROM trades"
  },
  {
    "query": "SELECT string_agg(symbol, ',') as symbols\nFROM (\n  SELECT symbol\n  FROM trades\n  LIMIT 10\n) sub"
  },
  {
    "query": "SELECT name, strpos(name, 'Thompson') idx\nFROM full_names\nLIMIT 4"
  },
  {
    "query": "SELECT name, position(name, 'Thompson') idx\nFROM full_names\nLIMIT 4"
  },
  {
    "query": "SELECT col,\n       left(col, strpos(col, ',') - 1) as col1,\n       right(col, length(col) - strpos(col, ',')) as col2\nFROM example_table"
  },
  {
    "query": "SELECT col,\n       left(col, position(col, ',') - 1) as col1,\n       right(col, length(col) - position(col, ',')) as col2\nFROM example_table"
  },
  {
    "query": "SELECT id, substring(id, 1, 2) country FROM orders LIMIT 3"
  },
  {
    "query": "SELECT substring('Lorem ipsum dolor sit amet', -5, 9)"
  },
  {
    "query": "SELECT lower('questDB')"
  },
  {
    "query": "SELECT to_lowercase('questDB')"
  },
  {
    "query": "SELECT upper('questDB')"
  },
  {
    "query": "SELECT to_uppercase('questDB')"
  },
  {
    "query": "SELECT replace('Hello World', 'World', 'QuestDB')"
  },
  {
    "query": "SELECT rtrim('Hello QuestDB   ')"
  },
  {
    "query": "SELECT split_part('Hello,QuestDB,SQL', ',', 2)"
  },
  {
    "query": "SELECT starts_with('Hello QuestDB', 'Hello')"
  },
  {
    "query": "SELECT quote_ident(\"a b\")"
  },
  {
    "query": "SELECT quote_ident(\"ab\")"
  },
  {
    "query": "SELECT *\nFROM trades\nWHERE timestamp > (SELECT min(timestamp) FROM trades)\n  AND timestamp < (SELECT max(timestamp) FROM trades)"
  },
  {
    "query": "CREATE TABLE\ntemperatures(ts timestamp, sensorID symbol, sensorLocation symbol, reading double)\ntimestamp(ts)"
  },
  {
    "query": "(SELECT cast(dateTime AS TIMESTAMP) ts, symbol, price FROM trades) timestamp(ts)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT ts, avg(price) FROM\n(SELECT cast(dateTime AS TIMESTAMP) ts, price FROM trades) timestamp(ts)\nSAMPLE BY 1d"
  },
  {
    "query": "SELECT ts, avg(price) FROM\n(SELECT ts, price FROM unordered_trades ORDER BY ts) timestamp(ts)\nSAMPLE BY 1d"
  },
  {
    "query": "CREATE TABLE x AS (\n  SELECT\n    rnd_geohash(40) g,\n    rnd_double(0)* 100 a,\n    rnd_symbol(5, 4, 4, 1) b,\n    timestamp_sequence(0, 100000000000) k\n  FROM\n    long_sequence(20)\n),\nindex(b) timestamp(k) PARTITION BY DAY"
  },
  {
    "query": "SELECT touch(SELECT * FROM x WHERE k IN '1970-01-22')",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT pi()/2 angle, sin(pi()/2) sin"
  },
  {
    "query": "SELECT pi()/2 angle, cos(pi()/2) cos"
  },
  {
    "query": "SELECT pi()/2 angle, tan(pi()/2) tan"
  },
  {
    "query": "SELECT pi()/2 angle, cot(pi()/2) cot"
  },
  {
    "query": "SELECT asin(1.0) asin"
  },
  {
    "query": "SELECT acos(0.0) acos"
  },
  {
    "query": "SELECT atan('-Infinity')"
  },
  {
    "query": "SELECT atan(1.0) atan"
  },
  {
    "query": "SELECT atan2(1.0, 1.0) atan2"
  },
  {
    "query": "SELECT radians(180)"
  },
  {
    "query": "SELECT degrees(pi())"
  },
  {
    "query": "SELECT pi()"
  },
  {
    "query": "SELECT to_uuid(2, 1)\nAS uuid FROM long_sequence(1)"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS moving_avg\nFROM trades\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT symbol, avg(price) AS avg_price\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT timestamp, symbol, price,\n       avg(price) OVER (PARTITION BY symbol) AS avg_price\nFROM trades"
  },
  {
    "query": "SELECT\n    timestamp,\n    amount,\n    sum(amount) OVER (\n        ORDER BY timestamp\n        CUMULATIVE\n    ) AS running_total\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "DECLARE @symbol := 'BTC-USDT'\n\nWITH ohlc AS (\n    SELECT\n        timestamp AS ts,\n        symbol,\n        first(price) AS open,\n        max(price) AS high,\n        min(price) AS low,\n        last(price) AS close,\n        sum(amount) AS volume\n    FROM trades\n    WHERE timestamp IN '2024-05-22' AND symbol = @symbol\n    SAMPLE BY 1m ALIGN TO CALENDAR\n)\nSELECT\n    ts,\n    symbol,\n    open, high, low, close, volume,\n    sum((high + low + close) / 3 * volume) OVER (ORDER BY ts CUMULATIVE)\n        / sum(volume) OVER (ORDER BY ts CUMULATIVE) AS vwap\nFROM ohlc\nORDER BY ts"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (PARTITION BY symbol) AS symbol_avg,\n    price - avg(price) OVER (PARTITION BY symbol) AS diff_from_avg\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    rank() OVER (\n        PARTITION BY symbol\n        ORDER BY price DESC\n    ) AS price_rank\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    lag(price) OVER (ORDER BY timestamp) AS prev_price,\n    price - lag(price) OVER (ORDER BY timestamp) AS price_change\nFROM trades\nWHERE timestamp IN '[$today]'\n    AND symbol = 'BTC-USDT'"
  },
  {
    "query": "SELECT symbol, price\nFROM trades\nWHERE avg(price) OVER (ORDER BY timestamp) > 100"
  },
  {
    "query": "SELECT * FROM prices\nWHERE moving_avg > 100"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (PARTITION BY symbol) AS avg_price  -- Same value for all rows in partition\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS running_avg\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS moving_avg\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'alpha', 0.2) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS ema_alpha\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'period', 10) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS ema_10\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'minute', 5) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS ema_5min\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'alpha', 0.1, amount) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS vwema_alpha\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'period', 10, amount) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS vwema_10\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price, 'hour', 1, amount) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS vwema_1h\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    timestamp,\n    count(*) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        RANGE BETWEEN '1' SECOND PRECEDING AND CURRENT ROW\n    ) AS trades_last_second\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    amount,\n    timestamp,\n    sum(amount) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_amount\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    ksum(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_price\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    ksum(price) OVER (\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS rolling_sum\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    min(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS lowest_price\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    max(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS highest_price\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    first_value(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS first_price,\n    first_value(price) IGNORE NULLS OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS first_non_null_price\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    last_value(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS last_price,\n    last_value(price) IGNORE NULLS OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS last_non_null_price\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    row_number() OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS trade_number\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    dense_rank() OVER (\n        PARTITION BY symbol\n        ORDER BY price DESC\n    ) AS price_rank\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    percent_rank() OVER (\n        PARTITION BY symbol\n        ORDER BY price DESC\n    ) AS price_percentile\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    rank() OVER (ORDER BY price DESC) AS rank,\n    percent_rank() OVER (ORDER BY price DESC) AS percent_rank\nFROM trades\nWHERE timestamp IN '[$today]'\n    AND symbol = 'BTC-USDT'"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    lag(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS previous_price,\n    lag(price, 2, 0.0) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS price_two_rows_back\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    lead(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS next_price,\n    lead(price, 2, 0.0) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS price_after_next\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "DECLARE @best_bid := bids[1,1]\nSELECT\n    timestamp,\n    symbol,\n    @best_bid AS best_bid,\n    avg(@best_bid) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n    ) AS bid_moving_avg\nFROM market_data\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "DECLARE\n  @best_bid := bids[1,1],\n  @volume_l1 := bids[2,1]\nSELECT\n    timestamp, symbol,\n    @best_bid AS bid_price_l1,\n    @volume_l1 AS bid_volume_l1,\n    sum(@volume_l1) OVER (\n        PARTITION BY symbol ORDER BY timestamp\n        ROWS BETWEEN 5 PRECEDING AND CURRENT ROW\n    ) AS bid_volume_l1_5rows\nFROM market_data\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "DECLARE\n    @best_bid := bids[1,1],\n    @volume_l1 := bids[2,1]\nSELECT\n    timestamp,\n    sum(@volume_l1) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN '1' MINUTE PRECEDING AND CURRENT ROW\n    ) AS bid_volume_1min\nFROM market_data\nWHERE timestamp IN '[$today]' AND symbol = 'GBPUSD'"
  },
  {
    "query": "SELECT\n    timestamp,\n    symbol,\n    COUNT(*) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN 60000000 PRECEDING AND CURRENT ROW\n    ) AS updates_per_min,\n    COUNT(CASE WHEN side = 'buy' THEN 1 END) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN 60000000 PRECEDING AND CURRENT ROW\n    ) AS buys_per_minute,\n    COUNT(CASE WHEN side = 'sell' THEN 1 END) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN 60000000 PRECEDING AND CURRENT ROW\n    ) AS sells_per_minute\nFROM trades\nWHERE timestamp IN '[$today]' AND symbol = 'BTC-USDT'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (PARTITION BY symbol) AS avg_price_per_symbol\nFROM trades\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    row_number() OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS seq\nFROM trades\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    lag(price) OVER (ORDER BY timestamp) AS prev_price\nFROM trades"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    lag(price) IGNORE NULLS OVER (ORDER BY timestamp) AS prev_non_null_price\nFROM trades"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    avg(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS moving_avg_3\nFROM trades\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT\n    timestamp,\n    bids[1,1] AS best_bid,\n    bids[2,1] AS volume_l1,\n    AVG(best_bid) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN '5' MINUTE PRECEDING AND CURRENT ROW\n    ) AS avg_5min,\n    COUNT(*) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN '100' MILLISECOND PRECEDING AND CURRENT ROW\n    ) AS updates_100ms,\n    SUM(volume_l1) OVER (\n        ORDER BY timestamp\n        RANGE BETWEEN '2' SECOND PRECEDING AND CURRENT ROW\n    ) AS volume_2sec\nFROM market_data\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    sum(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        CUMULATIVE\n    ) AS running_total\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    sum(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS running_total\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "DECLARE @symbol := 'BTC-USDT'\n\nWITH ohlc AS (\n    SELECT\n        timestamp AS ts,\n        first(price) AS open,\n        max(price) AS high,\n        min(price) AS low,\n        last(price) AS close,\n        sum(amount) AS volume\n    FROM trades\n    WHERE timestamp IN '2024-05-22' AND symbol = @symbol\n    SAMPLE BY 1m ALIGN TO CALENDAR\n)\nSELECT\n    ts, open, high, low, close, volume,\n    sum((high + low + close) / 3 * volume) OVER (ORDER BY ts CUMULATIVE)\n        / sum(volume) OVER (ORDER BY ts CUMULATIVE) AS vwap\nFROM ohlc"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    -- These are equivalent:\n    sum(price) OVER (ORDER BY timestamp ROWS UNBOUNDED PRECEDING) AS sum1,\n    sum(price) OVER (ORDER BY timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS sum2,\n    sum(price) OVER (ORDER BY timestamp CUMULATIVE) AS sum3\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    timestamp,\n    price,\n    SUM(price) OVER (\n        ORDER BY timestamp\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        EXCLUDE CURRENT ROW\n    ) AS cumulative_sum_excluding_current\nFROM trades\nWHERE timestamp IN '[$today]'\nLIMIT 100"
  },
  {
    "query": "SELECT * FROM prices_and_avg\nWHERE moving_avg_price > 100"
  },
  {
    "query": "-- Potential issue: all rows show the same sum\nSELECT\n    symbol,\n    price,\n    timestamp,\n    sum(price) OVER () AS total_sum\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "-- Potential issue: same value for all rows in each partition\nSELECT\n    symbol,\n    price,\n    timestamp,\n    sum(price) OVER (PARTITION BY symbol) AS symbol_total\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT\n    symbol,\n    price,\n    timestamp,\n    sum(price) OVER (\n        PARTITION BY symbol\n        ORDER BY timestamp\n    ) AS cumulative_sum\nFROM trades\nWHERE timestamp IN '[$today]'"
  },
  {
    "query": "SELECT ~1024"
  },
  {
    "query": "SELECT 5 & 3"
  },
  {
    "query": "SELECT 5 ^ 3"
  },
  {
    "query": "SELECT 5 | 3"
  },
  {
    "query": "SELECT 5 IN (1, 2, 7, 5, 8)"
  },
  {
    "query": "SELECT '5' = '5'"
  },
  {
    "query": "SELECT 5 = 5"
  },
  {
    "query": "SELECT '5' = '3'"
  },
  {
    "query": "SELECT 5 = 3"
  },
  {
    "query": "SELECT 'abc' > 'def'"
  },
  {
    "query": "SELECT '5' > '5'"
  },
  {
    "query": "SELECT 'a' > 'b'"
  },
  {
    "query": "SELECT 'abc' >= 'def'"
  },
  {
    "query": "SELECT '5' >= '5'"
  },
  {
    "query": "SELECT '7' >= '5'"
  },
  {
    "query": "SELECT 'a' >= 'b'"
  },
  {
    "query": "SELECT '123' < '456'"
  },
  {
    "query": "SELECT 5 < 5"
  },
  {
    "query": "SELECT 5 < 3"
  },
  {
    "query": "SELECT '123' <= '456'"
  },
  {
    "query": "SELECT 5 <= 5"
  },
  {
    "query": "SELECT 5 <= 3"
  },
  {
    "query": "SELECT '5' <> '5'"
  },
  {
    "query": "SELECT 5 <> 5"
  },
  {
    "query": "SELECT 'a' <> 'b'"
  },
  {
    "query": "SELECT 5 <> 3"
  },
  {
    "query": "SELECT * FROM scores\nWHERE ts IN ('2018-01-01', '2018-01-01T12:00', '2018-01-02')"
  },
  {
    "query": "SELECT * FROM scores\nWHERE ts = '2018-01-01' or ts = '2018-01-01T12:00' or ts = '2018-01-02'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:30;1h'"
  },
  {
    "query": "-- Multiple dates with bracket expansion\nSELECT * FROM trades WHERE ts IN '2024-01-[15,16,17]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-[01..31]T09:30@EST#wd;6h30m'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[$today-5bd..$today-1bd]'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN interval('2024-01-01', '2024-01-31')"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts BETWEEN '2024-01-01T00:00:00Z' AND '2024-01-31T23:59:59Z'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts BETWEEN dateadd('d', -7, now()) AND now()"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2025-01-[01..31]#XNYS'"
  },
  {
    "query": "SELECT reload_tick_calendars()"
  },
  {
    "query": "-- Add a Saturday trading session to NYSE\nINSERT INTO _tick_calendars_custom\n    (exchange, session, open, close)\nVALUES\n    ('XNYS', '2025-01-25',\n     '2025-01-25T10:00:00.000000Z', '2025-01-25T14:00:00.000000Z')"
  },
  {
    "query": "-- Override NYSE Jan 27: late open at 16:00 instead of 14:30\nINSERT INTO _tick_calendars_custom\n    (exchange, session, open, close)\nVALUES\n    ('XNYS', '2025-01-27',\n     '2025-01-27T16:00:00.000000Z', '2025-01-27T21:00:00.000000Z')"
  },
  {
    "query": "-- Close NYSE on Jan 27 (remove the built-in session entirely)\nINSERT INTO _tick_calendars_custom\n    (exchange, session)\nVALUES\n    ('XNYS', '2025-01-27')"
  },
  {
    "query": "-- Define a custom exchange with a lunch break\nINSERT INTO _tick_calendars_custom\n    (exchange, session, open, break_start, break_end, close)\nVALUES\n    ('MINE', '2025-03-03',\n     '2025-03-03T09:00:00.000000Z', '2025-03-03T12:00:00.000000Z',\n     '2025-03-03T13:00:00.000000Z', '2025-03-03T17:00:00.000000Z'),\n    ('MINE', '2025-03-04',\n     '2025-03-04T09:00:00.000000Z', '2025-03-04T12:00:00.000000Z',\n     '2025-03-04T13:00:00.000000Z', '2025-03-04T17:00:00.000000Z')"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2025-03-[03..04]#MINE'"
  },
  {
    "query": "UPDATE _tick_calendars_custom\nSET deleted = true\nWHERE exchange = 'XNYS' AND session = '2025-01-27'"
  },
  {
    "query": "SELECT * FROM tick_calendars() WHERE exchange = 'XNYS'"
  },
  {
    "query": "-- Check a specific session\nSELECT * FROM tick_calendars()\nWHERE exchange = 'XNYS' AND session = '2025-01-27'"
  },
  {
    "query": "SELECT * FROM (SELECT 5 AS a, 10 AS b) WHERE A = 5 OR B = 2"
  },
  {
    "query": "SELECT * FROM (SELECT 5 AS a, 10 AS b) WHERE A = 3 OR B = 2"
  },
  {
    "query": "SELECT * FROM (SELECT 5 AS a, 10 AS b) WHERE A = 5 AND B = 2"
  },
  {
    "query": "SELECT * FROM (SELECT 5 AS a, 10 AS b) WHERE A = 5 AND B = 10"
  },
  {
    "query": "SELECT NOT TRUE"
  },
  {
    "query": "SELECT 5::float, cast(5 as float)"
  },
  {
    "query": "SELECT 5 + 2"
  },
  {
    "query": "SELECT 5 / 2, 5.0 / 2.0"
  },
  {
    "query": "SELECT 5 % 2"
  },
  {
    "query": "SELECT 5 - 2"
  },
  {
    "query": "SELECT -5"
  },
  {
    "query": "(\nSELECT pickup_datetime, \n       make_geohash(pickup_latitude, \n                    pickup_longitude, \n                    60) pickup_geohash\nFROM trips\nLIMIT 5\n)\nWHERE pickup_geohash WITHIN (#dr5ru)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM pos\nWHERE g8c within(#ezz, #u33d8)\nLATEST ON ts PARTITION BY uuid"
  },
  {
    "query": "SELECT * FROM pos\nWHERE g8c within(#u33)\nLATEST ON ts PARTITION BY uuid"
  },
  {
    "query": "SELECT 'a' || 'b'"
  },
  {
    "query": "SELECT address FROM (SELECT 'abc@foo.com' as address) WHERE address ~ '@foo.com'"
  },
  {
    "query": "SELECT address FROM (SELECT 'abc@foo.com' as address) WHERE address !~ '@bah.com'"
  },
  {
    "query": "SELECT 'abc' LIKE '%c', 'abc' LIKE 'a_c'"
  },
  {
    "query": "SELECT 'abC' LIKE '%c', 'abC' ILIKE '%c'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2025-01-[02..8,10..19,21..31]T09:30@America/New_York#workday;6h30m'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[$today, $yesterday, 2024-01-15]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[$today, $today - 7d]T09:30;6h30m'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[$now - 4h, $now - 3h, $now - 2h, $now - 1h, $now]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-[10,15,20]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-[10..15]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-[5,10..12,20]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-[01,06]-[10,15]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[2024-01-15,2024-03-20,2024-06-01]'"
  },
  {
    "query": "-- With nested bracket expansion\nSELECT * FROM trades WHERE ts IN '[2024-12-31,2025-01-[01..05]]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[2024-01-15,2024-01-20]T09:30'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '[2024-01-15,2024-01-20]T09:30;6h30m'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T[09:00,18:00];1h'"
  },
  {
    "query": "SELECT * FROM metrics WHERE ts IN '2024-01-15T[08:00,12:00,18:00];30m'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:30@America/New_York'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:30@+02:00'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:30@UTC'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '2024-01-15T[09:30@America/New_York,08:00@Europe/London,09:00@Asia/Tokyo];6h'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '[2024-01-15@Europe/London,2024-07-15@Europe/London]T08:00'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-[01..31]#workday'"
  },
  {
    "query": "SELECT * FROM logs WHERE ts IN '2024-01-[01..31]T02:00#weekend;4h'"
  },
  {
    "query": "SELECT * FROM attendance WHERE ts IN '2024-01-[01..31]#Mon,Wed,Fri'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:00;1h'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-01-15T09:30;6h30m'"
  },
  {
    "query": "-- Precise sub-second duration\nSELECT * FROM hft_data WHERE ts IN '2024-01-15T09:30:00;1s500T'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W01'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W01-1'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W01-5T09:00'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W[01..04]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W01-[1..5]'"
  },
  {
    "query": "SELECT * FROM trades WHERE ts IN '2024-W[01..04]-[1,5]'"
  },
  {
    "query": "SELECT * FROM nyse_trades\nWHERE ts IN '2024-01-[01..31]T09:30@America/New_York#workday;6h30m'"
  },
  {
    "query": "SELECT * FROM global_trades\nWHERE ts IN '2024-01-15T[09:30@America/New_York,08:00@Europe/London,09:00@Asia/Tokyo];6h'"
  },
  {
    "query": "SELECT * FROM standup_notes\nWHERE ts IN '2024-W[01..52]-1T09:00;1h'"
  },
  {
    "query": "SELECT * FROM reports\nWHERE ts IN '2024-W[02,04,06,08,10,12]-5T14:00;2h'"
  },
  {
    "query": "SELECT * FROM prices\nWHERE ts IN '[$today - 5bd..$today - 1bd]T09:30@America/New_York;1m'"
  },
  {
    "query": "SELECT * FROM metrics\nWHERE ts IN '[$today - 2d, $yesterday, $today]T14:00;1h'"
  },
  {
    "query": "SELECT * FROM sensor_data\nWHERE ts IN '$now - 2h..$now'"
  },
  {
    "query": "SELECT * FROM metrics\nWHERE ts IN '$now - 30m..$now'"
  },
  {
    "query": "SELECT * FROM logs\nWHERE ts IN '$now - 90s..$now'"
  },
  {
    "query": "SELECT * FROM hft_data\nWHERE ts IN '$now - 500T..$now'"
  },
  {
    "query": "SELECT * FROM trades\nWHERE ts IN '[$now - 4h, $now - 3h, $now - 2h, $now - 1h, $now];5m'"
  },
  {
    "query": "SELECT * FROM system_logs\nWHERE ts IN '2024-01-[01..31]T02:00#weekend;4h'"
  },
  {
    "query": "SELECT * FROM maintenance\nWHERE ts IN '2024-[01,04,07,10]-[01..07]T02:00#Sun;6h'"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades\nWHERE ts IN '2024-01-[15,16,17]T09:00;1h'"
  },
  {
    "query": "SELECT\n    timestamp, symbol,\n    first(price) AS open,\n    last(price) AS close,\n    min(price),\n    max(price),\n    sum(amount) AS volume\nFROM trades\nWHERE  timestamp > dateadd('d', -1, now())\nSAMPLE BY 15m"
  },
  {
    "query": "SELECT\n  *\nFROM\n  read_parquet('trades.parquet')\nWHERE\n  side = 'buy'"
  },
  {
    "query": "SELECT timestamp,\n       symbol,\n       avg(price) as avg_price,\n       min(price) as min_price,\n       max(price) as max_price\nFROM trades\nWHERE timestamp >= dateadd('d', -7, now()) SAMPLE BY 1h"
  },
  {
    "query": "SELECT *\nFROM trades\nWHERE timestamp IN today()\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "INSERT INTO my_table (decimal_column) VALUES (123.45m)"
  },
  {
    "query": "ADD USER john to management, audit"
  },
  {
    "query": "SHOW GROUPS john"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app ENABLE"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app DISABLE"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app WITH PASSWORD '1m@re@lh@cker'"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app WITH NO PASSWORD"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app CREATE TOKEN TYPE JWK"
  },
  {
    "query": "ALTER SERVICE ACCOUNT client_app DROP TOKEN TYPE JWK"
  },
  {
    "query": "SHOW SERVICE ACCOUNT client_app"
  },
  {
    "query": "-- generate a token with no TTL refresh\nALTER SERVICE ACCOUNT client_app CREATE TOKEN TYPE REST WITH TTL '1m'"
  },
  {
    "query": "-- generate a token with TTL refresh\nALTER SERVICE ACCOUNT client_app CREATE TOKEN TYPE REST WITH TTL '1m' REFRESH"
  },
  {
    "query": "-- drop single REST API token\nALTER SERVICE ACCOUNT client_app DROP TOKEN TYPE REST 'qt1cNK6s2t79f76GmTBN9k7XTWm5wwOtF7C0UBxiHGPn44'"
  },
  {
    "query": "-- drop all REST API tokens for the given service account\nALTER SERVICE ACCOUNT client_app DROP TOKEN TYPE REST"
  },
  {
    "query": "ALTER USER john ENABLE"
  },
  {
    "query": "ALTER USER john DISABLE"
  },
  {
    "query": "ALTER USER john WITH PASSWORD '1m@re@lh@cker'"
  },
  {
    "query": "ALTER USER john WITH NO PASSWORD"
  },
  {
    "query": "ALTER USER john CREATE TOKEN TYPE JWK"
  },
  {
    "query": "ALTER USER john DROP TOKEN TYPE JWK"
  },
  {
    "query": "SHOW USER john"
  },
  {
    "query": "-- generate a token with no TTL refresh\nALTER USER john CREATE TOKEN TYPE REST WITH TTL '1m'"
  },
  {
    "query": "-- generate a token with TTL refresh\nALTER USER john CREATE TOKEN TYPE REST WITH TTL '1m' REFRESH"
  },
  {
    "query": "-- drop single REST API token\nALTER USER john DROP TOKEN TYPE REST 'qt1cNK6s2t79f76GmTBN9k7XTWm5wwOtF7C0UBxiHGPn44'"
  },
  {
    "query": "-- drop all REST API tokens for the given user\nALTER USER john DROP TOKEN TYPE REST"
  },
  {
    "query": "ASSUME SERVICE ACCOUNT ilp_ingestion"
  },
  {
    "query": "CREATE GROUP admins"
  },
  {
    "query": "CREATE GROUP IF NOT EXISTS admins"
  },
  {
    "query": "SHOW GROUPS"
  },
  {
    "query": "CREATE SERVICE ACCOUNT audit"
  },
  {
    "query": "CREATE SERVICE ACCOUNT IF NOT EXISTS audit"
  },
  {
    "query": "SHOW SERVICE ACCOUNT audit"
  },
  {
    "query": "CREATE USER IF NOT EXISTS john WITH PASSWORD secret"
  },
  {
    "query": "CREATE USER IF NOT EXISTS john WITH NO PASSWORD"
  },
  {
    "query": "CREATE USER john"
  },
  {
    "query": "CREATE USER IF NOT EXISTS john"
  },
  {
    "query": "CREATE USER john WITH NO PASSWORD"
  },
  {
    "query": "CREATE USER jane WITH PASSWORD secret"
  },
  {
    "query": "DROP GROUP admins"
  },
  {
    "query": "DROP GROUP IF EXISTS admins"
  },
  {
    "query": "DROP SERVICE ACCOUNT audit"
  },
  {
    "query": "DROP SERVICE ACCOUNT IF EXISTS audit"
  },
  {
    "query": "SHOW SERVICE ACCOUNTS"
  },
  {
    "query": "DROP USER john"
  },
  {
    "query": "DROP USER IF EXISTS john"
  },
  {
    "query": "SHOW USERS"
  },
  {
    "query": "EXIT SERVICE ACCOUNT audit"
  },
  {
    "query": "GRANT ASSUME SERVICE ACCOUNT ingestion TO john"
  },
  {
    "query": "GRANT ASSUME SERVICE ACCOUNT ingestion TO john WITH GRANT OPTION"
  },
  {
    "query": "CREATE SERVICE ACCOUNT ingestion"
  },
  {
    "query": "SHOW SERVICE ACCOUNTS john"
  },
  {
    "query": "GRANT CREATE TABLE, SNAPSHOT TO john"
  },
  {
    "query": "GRANT ADD INDEX, REINDEX ON ALL TABLES TO john"
  },
  {
    "query": "GRANT ADD INDEX, REINDEX ON orders, trades TO john"
  },
  {
    "query": "GRANT SELECT ON ALL TABLES TO john"
  },
  {
    "query": "GRANT SELECT ON orders TO john"
  },
  {
    "query": "GRANT SELECT ON orders(id, name), trades(id, quantity) TO john"
  },
  {
    "query": "GRANT SELECT ON ALL TABLES TO john WITH GRANT OPTION"
  },
  {
    "query": "GRANT SELECT ON orders TO john WITH VERIFICATION"
  },
  {
    "query": "CREATE TABLE products(id int, name string, ts timestamp) timestamp(ts)"
  },
  {
    "query": "GRANT UPDATE ON products(id) TO john"
  },
  {
    "query": "GRANT INSERT ON ALL TABLES TO john"
  },
  {
    "query": "GRANT INSERT ON products TO john"
  },
  {
    "query": "GRANT SELECT ON products TO john"
  },
  {
    "query": "GRANT SELECT ON products(id) TO john"
  },
  {
    "query": "GRANT SELECT ON countries TO john"
  },
  {
    "query": "GRANT UPDATE ON countries(id) TO john"
  },
  {
    "query": "GRANT UPDATE ON countries(description) TO john"
  },
  {
    "query": "CREATE TABLE countries (id INT, name STRING, iso_code STRING)"
  },
  {
    "query": "ALTER TABLE countries ADD COLUMN description string"
  },
  {
    "query": "GRANT UPDATE ON countries(iso_code) TO john"
  },
  {
    "query": "DROP TABLE countries"
  },
  {
    "query": "CREATE TABLE countries (id INT, name STRING, iso_code int, alpha2 STRING)"
  },
  {
    "query": "REMOVE USER john from management, audit"
  },
  {
    "query": "REVOKE ASSUME SERVICE ACCOUNT ingestion FROM john"
  },
  {
    "query": "REVOKE CREATE TABLE FROM john"
  },
  {
    "query": "REVOKE ADD INDEX, REINDEX ON ALL TABLES FROM john"
  },
  {
    "query": "REVOKE ADD INDEX, REINDEX ON orders FROM john"
  },
  {
    "query": "REVOKE SELECT ON ALL TABLES FROM john"
  },
  {
    "query": "REVOKE SELECT ON orders, trades FROM john"
  },
  {
    "query": "REVOKE SELECT ON orders(id, name) FROM john"
  },
  {
    "query": "CREATE TABLE products(id INT, name STRING, ts TIMESTAMP) TIMESTAMP(ts)"
  },
  {
    "query": "GRANT SELECT, UPDATE ON products(name) TO john"
  },
  {
    "query": "REVOKE UPDATE ON products(name) FROM john"
  },
  {
    "query": "REVOKE SELECT ON products(id) FROM john"
  },
  {
    "query": "REVOKE SELECT ON trades FROM john"
  },
  {
    "query": "CREATE TABLE new_tab( id INT )"
  },
  {
    "query": "REVOKE SELECT on products(id) FROM john"
  },
  {
    "query": "CREATE group admins"
  },
  {
    "query": "GRANT SELECT on products to admins"
  },
  {
    "query": "ADD USER john to admins"
  },
  {
    "query": "REVOKE SELECT on products from john"
  },
  {
    "query": "REVOKE SELECT on products FROM admins"
  },
  {
    "query": "-- or\nREMOVE USER john FROM admins"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly\n  ALTER COLUMN symbol ADD INDEX"
  },
  {
    "query": "GRANT ALTER MATERIALIZED VIEW ON trades_hourly TO user1"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly\n  ALTER COLUMN symbol DROP INDEX"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_1h RESUME WAL"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_1h RESUME WAL FROM TRANSACTION 5"
  },
  {
    "query": "GRANT ALTER MATERIALIZED VIEW ON trades_1h TO user1"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH LIMIT 1 WEEK"
  },
  {
    "query": "INSERT INTO trades VALUES\n  ('2025-03-02T12:00:00Z', 'BTC-USD', 39269.98, 0.042),  -- 2 months old, ignored\n  ('2025-04-02T12:00:00Z', 'BTC-USD', 39170.01, 0.042),  -- 1 month old, ignored\n  ('2025-05-02T12:00:00Z', 'BTC-USD', 38450.10, 0.042)"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH LIMIT 1 DAY"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH LIMIT 8h"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH LIMIT 2 WEEKS"
  },
  {
    "query": "REFRESH MATERIALIZED VIEW trades_hourly\n  RANGE FROM '2025-03-01T00:00:00Z' TO '2025-03-02T00:00:00Z'"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly\nSET REFRESH EVERY 12h START '2025-12-31T00:00:00Z' TIME ZONE 'Europe/London'"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_daily\nSET REFRESH PERIOD (LENGTH 1d DELAY 1h)"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly\nSET REFRESH PERIOD (SAMPLE BY INTERVAL)"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH IMMEDIATE"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET REFRESH MANUAL"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET TTL 3 DAYS"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_hourly SET TTL 12h"
  },
  {
    "query": "ALTER MATERIALIZED VIEW trades_daily SET TTL 1 YEAR"
  },
  {
    "query": "ALTER TABLE ratings ADD COLUMN comment STRING"
  },
  {
    "query": "ALTER TABLE ratings ADD COLUMN IF NOT EXISTS score DOUBLE"
  },
  {
    "query": "ALTER TABLE ratings ADD COLUMN comment SYMBOL NOCACHE INDEX"
  },
  {
    "query": "ALTER TABLE trades ALTER COLUMN instrument ADD INDEX"
  },
  {
    "query": "ALTER TABLE 'taxi_ride' ALTER COLUMN passenger_count NOCACHE"
  },
  {
    "query": "ALTER TABLE trades ALTER COLUMN instrument DROP INDEX"
  },
  {
    "query": "UPDATE tab SET column=column"
  },
  {
    "query": "ALTER TABLE x ATTACH PARTITION LIST '2019-02-01', '2019-02-02'"
  },
  {
    "query": "CREATE TABLE tab (name STRING, age INT, dob TIMESTAMP) TIMESTAMP(dob) PARTITION BY YEAR"
  },
  {
    "query": "INSERT INTO tab VALUES('B', 1, '2022-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('C', 2, '2023-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('D', 3, '2024-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('E', 4, '2025-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('F', 5, '2026-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('A', 0, '2027-11-08T12:00:00.000000Z')"
  },
  {
    "query": "INSERT INTO tab VALUES('0', 0, '2028-11-08T12:00:00.000000Z')"
  },
  {
    "query": "ALTER TABLE tab DETACH PARTITION WHERE dob < '2028'"
  },
  {
    "query": "ALTER TABLE tab ATTACH PARTITION LIST '2022', '2023', '2024', '2025', '2026', '2027'"
  },
  {
    "query": "ALTER TABLE employees ALTER COLUMN age TYPE INT"
  },
  {
    "query": "ALTER TABLE tbl ALTER COLUMN col_name TYPE DOUBLE"
  },
  {
    "query": "ALTER TABLE tbl ALTER COLUMN department TYPE SYMBOL CAPACITY 10000 CACHE"
  },
  {
    "query": "ALTER TABLE employees ALTER COLUMN department TYPE SYMBOL CAPACITY 4096"
  },
  {
    "query": "ALTER TABLE x ALTER COLUMN ik SYMBOL CAPACITY 512"
  },
  {
    "query": "ALTER TABLE employees ALTER COLUMN department SYMBOL CAPACITY 10000"
  },
  {
    "query": "ALTER TABLE x DETACH PARTITION LIST '2019-02-01', '2019-02-02'"
  },
  {
    "query": "-- It is also possible to use WHERE clause to define the partition list:\n\n   ALTER TABLE sensors DETACH PARTITION WHERE timestamp < '2019-02-03T00'"
  },
  {
    "query": "ALTER TABLE TICKER_PRICE DEDUP DISABLE"
  },
  {
    "query": "ALTER TABLE ratings DROP COLUMN movieId"
  },
  {
    "query": "--DAY\nALTER TABLE measurements DROP PARTITION LIST '2019-05-18'"
  },
  {
    "query": "--MONTH\nALTER TABLE measurements DROP PARTITION LIST '2019-05'"
  },
  {
    "query": "--YEAR\nALTER TABLE measurements DROP PARTITION LIST '2019'"
  },
  {
    "query": "ALTER TABLE measurements DROP PARTITION LIST '2018','2019'"
  },
  {
    "query": "ALTER TABLE measurements\nDROP PARTITION\nWHERE timestamp = to_timestamp('2019-01-01:00:00:00', 'yyyy-MM-dd:HH:mm:ss')"
  },
  {
    "query": "ALTER TABLE measurements\nDROP PARTITION\nWHERE timestamp < to_timestamp('2018-01-01:00:00:00', 'yyyy-MM-dd:HH:mm:ss')"
  },
  {
    "query": "ALTER TABLE TICKER_PRICE DEDUP ENABLE UPSERT KEYS(ts, ticker)"
  },
  {
    "query": "ALTER TABLE measurements RENAME COLUMN sensor TO hum_sensor_1"
  },
  {
    "query": "ALTER TABLE trades RESUME WAL"
  },
  {
    "query": "ALTER TABLE trades RESUME WAL FROM TRANSACTION 5"
  },
  {
    "query": "ALTER TABLE trades RESUME WAL FROM TXN 5"
  },
  {
    "query": "SELECT writerTxn\nFROM wal_tables()\nWHERE name = 'trades'"
  },
  {
    "query": "SELECT max(sequencertxn)\nFROM wal_transactions('trades')\nWHERE sequencertxn > 1223\n  AND walId = 45\n  AND segmentId = 101"
  },
  {
    "query": "ALTER TABLE trades RESUME WAL FROM TXN 1243"
  },
  {
    "query": "ALTER TABLE my_table SET PARAM maxUncommittedRows = 10000"
  },
  {
    "query": "SELECT id, name, maxUncommittedRows FROM tables()"
  },
  {
    "query": "ALTER TABLE my_table SET PARAM o3MaxLag = 20s"
  },
  {
    "query": "ALTER TABLE weather SET TTL 3 WEEKS"
  },
  {
    "query": "ALTER TABLE weather SET TTL 12h"
  },
  {
    "query": "ALTER TABLE weather SET TYPE WAL"
  },
  {
    "query": "ALTER TABLE weather SET TYPE BYPASS WAL"
  },
  {
    "query": "ALTER TABLE x SQUASH PARTITIONS"
  },
  {
    "query": "SHOW PARTITIONS FROM x"
  },
  {
    "query": "CREATE VIEW summary AS (\n  SELECT ts, symbol, max(price) as max_price\n  FROM trades\n  SAMPLE BY 1h\n)"
  },
  {
    "query": "-- Alter to change aggregation\nALTER VIEW summary AS (\n  SELECT ts, symbol, avg(price) as avg_price\n  FROM trades\n  SAMPLE BY 1h\n)"
  },
  {
    "query": "CREATE VIEW trade_view AS (\n  SELECT ts, symbol, price FROM trades\n)"
  },
  {
    "query": "-- Add volume column\nALTER VIEW trade_view AS (\n  SELECT ts, symbol, price, quantity FROM trades\n)"
  },
  {
    "query": "CREATE VIEW filtered AS (\n  SELECT * FROM trades WHERE price > 100\n)"
  },
  {
    "query": "-- Change filter threshold\nALTER VIEW filtered AS (\n  SELECT * FROM trades WHERE price > 200\n)"
  },
  {
    "query": "CREATE VIEW by_price AS (\n  DECLARE @min := 0\n  SELECT * FROM trades WHERE price >= @min\n)"
  },
  {
    "query": "-- Change default value\nALTER VIEW by_price AS (\n  DECLARE @min := 100\n  SELECT * FROM trades WHERE price >= @min\n)"
  },
  {
    "query": "CREATE VIEW trades_filtered AS (\n  SELECT * FROM trades WHERE price > 100\n)"
  },
  {
    "query": "-- Add parameter\nALTER VIEW trades_filtered AS (\n  DECLARE @threshold := 100\n  SELECT * FROM trades WHERE price > @threshold\n)"
  },
  {
    "query": "CREATE VIEW my_view AS (SELECT * FROM table1)"
  },
  {
    "query": "-- UserB becomes the new \"definer\"\nALTER VIEW my_view AS (SELECT * FROM table2)"
  },
  {
    "query": "SELECT * FROM my_view;",
    "skipAutocomplete": true
  },
  {
    "query": "-- Grant ALTER VIEW permission\nGRANT ALTER VIEW ON my_view TO username"
  },
  {
    "query": "-- This fails if user doesn't have SELECT on secret_table\nALTER VIEW my_view AS (SELECT * FROM secret_table);\n-- Error: Access denied for username [SELECT on secret_table]",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT timestamp, symbol, bids[1,1] as best_bid_price\nFROM\n market_data limit 20"
  },
  {
    "query": "select timestamp, symbol, bid_price from\ncore_price limit 20"
  },
  {
    "query": "SELECT\n  m.timestamp, m.symbol, bids[1,1] AS best_bid_price,\n  p.timestamp, p.symbol, p.bid_price\nFROM\n  market_data m ASOF JOIN core_price p\nLIMIT 20",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT\n  m.timestamp, m.symbol, bids[1,1] AS best_bid_price,\n  p.timestamp, p.symbol, p.bid_price\nFROM\n  market_data m ASOF JOIN core_price p\nON (symbol)\nLIMIT 20",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT *\nFROM market_subset ASOF JOIN core_price ON (symbol)"
  },
  {
    "query": "SELECT *\nFROM trades_ordered_by_ingestion\nASOF JOIN quotes ON (symbol)"
  },
  {
    "query": "SELECT *\nFROM (\n      (SELECT * from read_parquet('trades.parquet') )\n      timestamp(timestamp)\n      )\nASOF JOIN trades ON (symbol)"
  },
  {
    "query": "SELECT market_data.timestamp, market_data.symbol, bids, core_price.*\nFROM market_data\nASOF JOIN core_price ON (symbol) TOLERANCE 50T\nWHERE market_data.timestamp IN today()",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT status, progress_percent FROM backups() ORDER BY start_ts DESC LIMIT 1"
  },
  {
    "query": "CREATE TABLE test AS (SELECT x FROM long_sequence(1000000000))"
  },
  {
    "query": "CANCEL QUERY 29"
  },
  {
    "query": "SELECT cancel_query(29)"
  },
  {
    "query": "SELECT cancel_query(query_id)\nFROM query_activity()\nWHERE query LIKE 'CREATE TABLE test_tab%'"
  },
  {
    "query": "SELECT\nname,\nCASE\n    WHEN age > 18 THEN 'major'\n    ELSE 'minor'\nEND\nFROM my_table"
  },
  {
    "query": "SELECT\nname,\nCASE\n    WHEN age > 18 THEN 'major'\nEND\nFROM my_table"
  },
  {
    "query": "SELECT\ncast(3L + 2L AS INT) cast1,\ncast(1578506142000000 AS TIMESTAMP) cast2,\ncast(1578506142000000 AS TIMESTAMP_NS) cast3,\ncast('10.2' AS DOUBLE) cast4,\ncast('1' AS INT) cast5"
  },
  {
    "query": "SELECT\ncast(3.5 + 2 AS INT),\ncast(7234623 AS SHORT),\ncast(2334444.323 AS SHORT)"
  },
  {
    "query": "SELECT\n1234L + 567,\n1234L + 0.567,\nto_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss') + 323,\nto_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss') + 0.323"
  },
  {
    "query": "SELECT\n    (3.5 + 2)::INT,\n    7234623::SHORT,\n    2334444.323::SHORT"
  },
  {
    "query": "COMPILE VIEW view_name",
    "skipAutocomplete": true
  },
  {
    "query": "COMPILE VIEW my_view",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT view_name, view_status, invalidation_reason\nFROM views()\nWHERE view_name = 'my_view'"
  },
  {
    "query": "-- If invalid, fix the underlying issue, then compile\nCOMPILE VIEW my_view",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT view_status FROM views() WHERE view_name = 'my_view';",
    "skipAutocomplete": true
  },
  {
    "query": "-- Compile each view after fixing underlying issues\nCOMPILE VIEW view1",
    "skipAutocomplete": true
  },
  {
    "query": "COMPILE VIEW view2",
    "skipAutocomplete": true
  },
  {
    "query": "COMPILE VIEW view3",
    "skipAutocomplete": true
  },
  {
    "query": "-- Grant COMPILE VIEW permission\nGRANT COMPILE VIEW ON my_view TO username"
  },
  {
    "query": "-- Grant on multiple views\nGRANT COMPILE VIEW ON view1, view2 TO username"
  },
  {
    "query": "COPY weather FROM 'weather.csv' WITH HEADER true FORMAT 'yyyy-MM-ddTHH:mm:ss.SSSUUUZ' ON ERROR SKIP_ROW"
  },
  {
    "query": "SELECT * FROM 'sys.text_import_log' WHERE id = '55ca24e5ba328050'"
  },
  {
    "query": "COPY '55ca24e5ba328050' CANCEL"
  },
  {
    "query": "SELECT * FROM 'sys.text_import_log' WHERE id = '55ca24e5ba328050' LIMIT -1"
  },
  {
    "query": "COPY trades TO 'trades_export' WITH FORMAT PARQUET"
  },
  {
    "query": "SELECT * FROM sys.copy_export_log WHERE id = '7f3a9c2e1b456789'"
  },
  {
    "query": "COPY (SELECT * FROM trades WHERE timestamp IN today() AND symbol = 'BTC-USDT')\nTO 'btc_today'\nWITH FORMAT PARQUET"
  },
  {
    "query": "COPY trades TO 'trades_daily'\nWITH FORMAT PARQUET\nPARTITION_BY DAY"
  },
  {
    "query": "COPY (\n    SELECT generate_series as date\n    FROM generate_series('2025-01-01', '2025-02-01', '1d')\n)\nTO 'dates'\nWITH FORMAT PARQUET\nPARTITION_BY DAY"
  },
  {
    "query": "COPY trades TO 'trades_compressed'\nWITH\n    FORMAT PARQUET\n    COMPRESSION_CODEC ZSTD\n    COMPRESSION_LEVEL 9\n    ROW_GROUP_SIZE 1000000\n    DATA_PAGE_SIZE 2097152"
  },
  {
    "query": "COPY (\n    SELECT\n        timestamp,\n        symbol,\n        first(price) AS open,\n        max(price) AS high,\n        min(price) AS low,\n        last(price) AS close,\n        sum(amount) AS volume\n    FROM trades\n    WHERE timestamp > dateadd('d', -7, now())\n    SAMPLE BY 1h\n)\nTO 'ohlcv_7d'\nWITH FORMAT PARQUET"
  },
  {
    "query": "SELECT ts, \"table\", destination, status, rows_exported\nFROM sys.copy_export_log\nWHERE ts > dateadd('d', -1, now())\nORDER BY ts DESC"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS\nSELECT\n  timestamp,\n  symbol,\n  avg(price) AS avg_price\nFROM trades\nSAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH IMMEDIATE AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH EVERY 10m AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH EVERY 1h START '2025-01-01T00:00:00Z' TIME ZONE 'Europe/Berlin' AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH MANUAL AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH IMMEDIATE DEFERRED AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_daily\nREFRESH PERIOD (LENGTH 1d TIME ZONE 'Europe/London' DELAY 2h) AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1d"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly\nREFRESH PERIOD (SAMPLE BY INTERVAL) AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades\nSAMPLE BY 1h ALIGN TO CALENDAR TIME ZONE 'Europe/London'"
  },
  {
    "query": "CREATE MATERIALIZED VIEW hourly_stats\nREFRESH EVERY 15m PERIOD (LENGTH 1h DELAY 5m) AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_daily\nREFRESH MANUAL PERIOD (LENGTH 1d TIME ZONE 'UTC' DELAY 1h) AS\nSELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1d"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_with_metadata\nWITH BASE trades AS\nSELECT\n  t.timestamp,\n  t.symbol,\n  m.description,\n  avg(t.price) AS avg_price\nFROM trades t\nJOIN instruments m ON t.symbol = m.symbol\nSAMPLE BY 1h",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS (\n  SELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h\n) PARTITION BY DAY"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS (\n  SELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h\n) PARTITION BY DAY TTL 7 DAYS"
  },
  {
    "query": "SELECT view_name, base_table_name, view_status, last_refresh_finish_timestamp\nFROM materialized_views()"
  },
  {
    "query": "CREATE GROUP analysts"
  },
  {
    "query": "CREATE MATERIALIZED VIEW trades_hourly AS (\n  SELECT timestamp, symbol, avg(price) AS avg_price FROM trades SAMPLE BY 1h\n) OWNED BY analysts"
  },
  {
    "query": "GRANT CREATE MATERIALIZED VIEW TO user1"
  },
  {
    "query": "GRANT SELECT ON trades TO user1"
  },
  {
    "query": "GRANT REFRESH MATERIALIZED VIEW ON trades_hourly TO user1"
  },
  {
    "query": "GRANT DROP MATERIALIZED VIEW ON trades_hourly TO user1"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nTTL 1 WEEK"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nTTL 1 WEEK\nDEDUP UPSERT KEYS (timestamp, symbol)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL CAPACITY 256 NOCACHE,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nTTL 1 WEEK\nDEDUP UPSERT KEYS (timestamp, symbol)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nDEDUP UPSERT KEYS (timestamp, symbol)"
  },
  {
    "query": "ALTER TABLE trades DEDUP ENABLE UPSERT KEYS (timestamp, symbol)"
  },
  {
    "query": "ALTER TABLE trades DEDUP DISABLE"
  },
  {
    "query": "SELECT dedup FROM tables() WHERE table_name = '<the table name>'"
  },
  {
    "query": "CREATE TABLE IF NOT EXISTS trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE \"example out of.space\" (a INT)"
  },
  {
    "query": "INSERT INTO \"example out of.space\" VALUES (1)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL CAPACITY 50,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL CAPACITY 50 NOCACHE,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE TABLE test AS (\n  SELECT x FROM long_sequence(10)\n), CAST (x AS DOUBLE)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n), INDEX(symbol) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nOWNED BY analysts"
  },
  {
    "query": "CREATE TABLE new_trades AS (\n  SELECT *\n  FROM\n    trades\n) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE TABLE new_trades AS (\n  SELECT *\n  FROM\n    trades\n), CAST(price AS LONG) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE ATOMIC TABLE new_trades AS (\n  SELECT *\n  FROM\n    trades\n) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE BATCH 4096 TABLE new_trades AS (\n  SELECT *\n  FROM\n    trades\n) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE BATCH 4096 o3MaxLag 1s TABLE new_trades AS (\n  SELECT * FROM trades\n) TIMESTAMP(timestamp)"
  },
  {
    "query": "CREATE TABLE trades AS (\n  SELECT * FROM trades_unordered ORDER BY timestamp\n) TIMESTAMP(timestamp)\nPARTITION BY MONTH"
  },
  {
    "query": "CREATE TABLE new_table (LIKE my_table)"
  },
  {
    "query": "CREATE TABLE trades (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  price DOUBLE,\n  amount DOUBLE\n) TIMESTAMP(timestamp)\nPARTITION BY DAY\nWITH maxUncommittedRows=250000"
  },
  {
    "query": "SELECT id, table_name, maxUncommittedRows FROM tables()"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE,\n    amount DOUBLE\n  ) TIMESTAMP(timestamp)\n  PARTITION BY DAY\n  WITH maxUncommittedRows=250000,\n  IN VOLUME SECONDARY_VOLUME"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE,\n    amount DOUBLE\n  ) TIMESTAMP(timestamp)\n  PARTITION BY DAY\n  IN VOLUME SECONDARY_VOLUME"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE,\n    amount DOUBLE\n  ) TIMESTAMP(timestamp)\n  PARTITION BY DAY\n  IN VOLUME 'SECONDARY_VOLUME'"
  },
  {
    "query": "CREATE VIEW my_view AS (\n  SELECT ts, symbol, price FROM trades\n)"
  },
  {
    "query": "CREATE VIEW hourly_ohlc AS (\n  SELECT\n    ts,\n    symbol,\n    first(price) as open,\n    max(price) as high,\n    min(price) as low,\n    last(price) as close,\n    sum(quantity) as volume\n  FROM trades\n  SAMPLE BY 1h\n)"
  },
  {
    "query": "CREATE VIEW high_value_trades AS (\n  SELECT ts, symbol, price, quantity\n  FROM trades\n  WHERE price * quantity > 10000\n)"
  },
  {
    "query": "CREATE VIEW enriched_trades AS (\n  SELECT t.ts, t.symbol, t.price, m.company_name\n  FROM trades t\n  JOIN metadata m ON t.symbol = m.symbol\n)",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE VIEW all_markets AS (\n  SELECT ts, symbol, price FROM nyse_trades\n  UNION ALL\n  SELECT ts, symbol, price FROM nasdaq_trades\n)"
  },
  {
    "query": "CREATE VIEW filtered_trades AS (\n  DECLARE @min_price := 100\n  SELECT ts, symbol, price FROM trades WHERE price >= @min_price\n)"
  },
  {
    "query": "SELECT * FROM filtered_trades\n-- Uses @min_price = 100"
  },
  {
    "query": "-- This fails with \"variable is not overridable: @min_price\"\nDECLARE @min_price := 500 SELECT * FROM filtered_trades"
  },
  {
    "query": "CREATE VIEW flexible_view AS (\n  DECLARE OVERRIDABLE @min_value := 0\n  SELECT * FROM trades WHERE value >= @min_value\n)"
  },
  {
    "query": "-- Override the default value\nDECLARE @min_value := 100 SELECT * FROM flexible_view"
  },
  {
    "query": "CREATE VIEW price_range AS (\n  DECLARE OVERRIDABLE @lo := 100, OVERRIDABLE @hi := 1000\n  SELECT ts, symbol, price FROM trades\n  WHERE price >= @lo AND price <= @hi\n)"
  },
  {
    "query": "-- Override one or both parameters\nDECLARE @lo := 50, @hi := 200 SELECT * FROM price_range"
  },
  {
    "query": "CREATE VIEW mixed_params AS (\n  DECLARE @fixed := 5, OVERRIDABLE @adjustable := 10\n  SELECT * FROM data WHERE a >= @fixed AND b <= @adjustable\n)"
  },
  {
    "query": "CREATE VIEW  AS (SELECT * FROM trades)"
  },
  {
    "query": "CREATE VIEW Rszvny_rak AS (SELECT * FROM prices)"
  },
  {
    "query": "CREATE VIEW with_timestamp AS (\n  (SELECT ts, value FROM my_view ORDER BY ts) timestamp(ts)\n)"
  },
  {
    "query": "CREATE VIEW trades_summary AS (\n  SELECT ts, symbol, sum(quantity) as volume\n  FROM trades\n  SAMPLE BY 1h\n)\nOWNED BY 'analysts'"
  },
  {
    "query": "SELECT @x"
  },
  {
    "query": "SELECT 5"
  },
  {
    "query": "SELECT @x + @y"
  },
  {
    "query": "SELECT @today = interval(@start, @end)"
  },
  {
    "query": "SELECT y FROM (\n    SELECT @x AS y\n)"
  },
  {
    "query": "SELECT @x + y FROM (\n    DECLARE @x := 10\n    SELECT @x AS y\n)"
  },
  {
    "query": "SELECT * FROM @subquery"
  },
  {
    "query": "SELECT a, b\nFROM second"
  },
  {
    "query": "SELECT @x::int + @y::int"
  },
  {
    "query": "SELECT @name as name, id FROM users WHERE name = @name"
  },
  {
    "query": "SELECT avg(@col), min(@col), max(@col)\nFROM trades\nWHERE symbol = @symbol"
  },
  {
    "query": "SELECT timestamp, price, symbol\nFROM trades\nWHERE symbol IN @symbols"
  },
  {
    "query": "DECLARE\n    @period := 1m,\n    @window := '2024-11-25',\n    @symbol := 'ETH-USDT'\nSELECT\n   timestamp, symbol, side, sum(amount) as volume\nFROM trades\nWHERE side = 'sell'\nAND timestamp IN @window\nAND symbol = @symbol\nSAMPLE BY @period\nFILL(NULL)"
  },
  {
    "query": "INSERT INTO trades (timestamp, symbol)\nSELECT * FROM\n(\n    DECLARE\n        @x := now(),\n        @y := 'ETH-USDT'\n    SELECT @x as timestamp, @y as symbol\n)"
  },
  {
    "query": "CREATE TABLE trades AS (\n    DECLARE\n        @x := now(),\n        @y := 'ETH-USDT'\n    SELECT @x as timestamp, @y as symbol, 123 as price\n)"
  },
  {
    "query": "SELECT DISTINCT movieId\nFROM ratings"
  },
  {
    "query": "SELECT DISTINCT movieId, count()\nFROM ratings"
  },
  {
    "query": "SELECT DISTINCT movieId, count()\nFROM ratings\nWHERE score > 3"
  },
  {
    "query": "DROP MATERIALIZED VIEW trades_hourly"
  },
  {
    "query": "DROP MATERIALIZED VIEW IF EXISTS trades_hourly"
  },
  {
    "query": "DROP VIEW IF EXISTS my_view"
  },
  {
    "query": "DROP VIEW view1"
  },
  {
    "query": "DROP VIEW view2"
  },
  {
    "query": "DROP VIEW view3"
  },
  {
    "query": "CREATE VIEW level1 AS (SELECT * FROM trades WHERE price > 0)"
  },
  {
    "query": "CREATE VIEW level2 AS (SELECT * FROM level1 WHERE quantity > 0)"
  },
  {
    "query": "-- Drop base view\nDROP VIEW level1"
  },
  {
    "query": "SELECT view_status FROM views() WHERE view_name = 'level2'"
  },
  {
    "query": "-- Grant DROP VIEW permission to a user\nGRANT DROP VIEW ON my_view TO username"
  },
  {
    "query": "-- Grant DROP VIEW permission on multiple views\nGRANT DROP VIEW ON view1, view2 TO username"
  },
  {
    "query": "DROP TABLE ratings"
  },
  {
    "query": "DROP ALL TABLES"
  },
  {
    "query": "CREATE TABLE trades (\n  symbol SYMBOL CAPACITY 256 CACHE,\n  side SYMBOL CAPACITY 256 CACHE,\n  price DOUBLE,\n  amount DOUBLE,\n  timestamp TIMESTAMP\n) TIMESTAMP (timestamp) PARTITION BY DAY"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades ORDER BY timestamp DESC"
  },
  {
    "query": "EXPLAIN SELECT * FROM trades WHERE amount > 100.0"
  },
  {
    "query": "EXPLAIN CREATE TABLE trades AS\n(\n  SELECT\n    rnd_symbol('a', 'b') symbol,\n    rnd_symbol('Buy', 'Sell') side,\n    rnd_double() price,\n    rnd_double() amount,\n    x::timestamp timestamp\n  FROM long_sequence(10)\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "EXPLAIN INSERT INTO trades\n  SELECT\n    rnd_symbol('a', 'b') symbol,\n    rnd_symbol('Buy', 'Sell') side,\n    rnd_double() price,\n    rnd_double() amount,\n    x::timestamp timestamp\n  FROM long_sequence(10)"
  },
  {
    "query": "EXPLAIN UPDATE trades SET amount = 0 WHERE timestamp IN '2022-11-11'"
  },
  {
    "query": "SELECT symbol, avg(price)\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT symbol, avg(price)\nFROM trades"
  },
  {
    "query": "SELECT symbol, side, avg(price)\nFROM trades\nGROUP BY symbol, side"
  },
  {
    "query": "SELECT symbol, side, avg(price)\nFROM trades"
  },
  {
    "query": "SELECT a, b, avg(temp)\nFROM tab\nGROUP BY a"
  },
  {
    "query": "SELECT a, avg(temp)\nFROM tab\nGROUP BY a, b"
  },
  {
    "query": "SELECT a, b, avg(temp)\nFROM tab\nGROUP BY a, b"
  },
  {
    "query": "INSERT INTO trades\nVALUES(\n    '2021-10-05T11:31:35.878Z',\n    'AAPL',\n    255,\n    123.33,\n    'B')"
  },
  {
    "query": "INSERT INTO trades\nVALUES\n    ('2021-10-05T11:31:35.878Z', 'AAPL', 245, 123.4, 'C'),\n    ('2021-10-05T12:31:35.878Z', 'AAPL', 245, 123.3, 'C'),\n    ('2021-10-05T13:31:35.878Z', 'AAPL', 250, 123.1, 'C'),\n    ('2021-10-05T14:31:35.878Z', 'AAPL', 250, 123.0, 'C')"
  },
  {
    "query": "INSERT INTO trades (timestamp, symbol, quantity, price, side)\nVALUES(\n    to_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),\n    'AAPL',\n    255,\n    123.33,\n    'B')"
  },
  {
    "query": "INSERT INTO trades (timestamp, symbol, price)\nVALUES(to_timestamp('2019-10-17T00:00:00', 'yyyy-MM-ddTHH:mm:ss'),'AAPL','B')"
  },
  {
    "query": "INSERT INTO confirmed_trades\n    SELECT timestamp, instrument, quantity, price, side\n    FROM unconfirmed_trades\n    WHERE trade_id = '47219345234'"
  },
  {
    "query": "WITH confirmed_id AS (\n    SELECT * FROM unconfirmed_trades\n    WHERE trade_id = '47219345234'\n)\nINSERT INTO confirmed_trades\nSELECT * FROM confirmed_id"
  },
  {
    "query": "INSERT ATOMIC INTO confirmed_trades\n    SELECT timestamp, instrument, quantity, price, side\n    FROM unconfirmed_trades\n    WHERE trade_id = '47219345234'"
  },
  {
    "query": "INSERT BATCH 4096 INTO confirmed_trades\n    SELECT timestamp, instrument, quantity, price, side\n    FROM unconfirmed_trades\n    WHERE trade_id = '47219345234'"
  },
  {
    "query": "INSERT BATCH 4096 o3MaxLag '1s' INTO confirmed_trades\n    SELECT timestamp, instrument, quantity, price, side\n    FROM unconfirmed_trades\n    WHERE trade_id = '47219345234'"
  },
  {
    "query": "SELECT *\nFROM Lookup\nINNER JOIN ManyTrades\n  ON Lookup.symbol = Manytrades.symbol"
  },
  {
    "query": "SELECT *\nFROM ManyTrades\nINNER JOIN Lookup\n  ON Lookup.symbol = Manytrades.symbol"
  },
  {
    "query": "SELECT *\nFROM a\nJOIN b ON (id)"
  },
  {
    "query": "SELECT *\nFROM mayTrades\nJOIN JuneTrades\n  ON mayTrades.symbol = juneTrades.symbol\n    AND mayTrades.side = juneTrades.side"
  },
  {
    "query": "SELECT *\nFROM mayTrades\nJOIN JuneTrades ON (symbol, side)"
  },
  {
    "query": "SELECT *\nFROM ManyTrades\nLEFT OUTER JOIN Lookup\n  ON Lookup.symbol = Manytrades.symbol"
  },
  {
    "query": "SELECT *\nFROM ManyTrades\nLEFT OUTER JOIN Lookup\n  ON Lookup.symbol = Manytrades.symbol\nWHERE Lookup.Symbol = NULL"
  },
  {
    "query": "SELECT * from t CROSS JOIN t AS t2\nWHERE t.timestamp < t2.timestamp\n  AND datediff('s', t.timestamp , t2.timestamp ) < 10\n  AND t.symbol = t2.symbol\n  AND t.side = t2.side\n  AND t.price = t2.price\n  AND t.amount = t2.amount"
  },
  {
    "query": "SELECT tradesA.timestamp, tradesB.timestamp, tradesA.price\nFROM miniTrades tradesA\nLT JOIN miniTrades tradesB",
    "skipAutocomplete": true
  },
  {
    "query": "WITH\nbuy AS (  -- select the first 5 buys in June 22\n  SELECT timestamp, price FROM trades\n  WHERE timestamp IN '2024-06-22' AND side = 'buy' LIMIT 2\n),\nsell AS ( -- select the first 5 sells in June 22\n  SELECT timestamp, price FROM trades\n  WHERE timestamp IN '2024-06-22' AND side = 'sell' LIMIT 2\n)\nSELECT\n  buy.timestamp, sell.timestamp, buy.price, sell.price\nFROM buy\nSPLICE JOIN sell",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT *\nFROM ManyTrades\nLEFT JOIN Lookup\n  ON Lookup.symbol = Manytrades.symbol"
  },
  {
    "query": "SELECT symbol, timestamp, price\nFROM trades\nLATEST ON timestamp PARTITION BY symbol"
  },
  {
    "query": "CREATE TABLE balances (\n    cust_id SYMBOL,\n    balance_ccy SYMBOL,\n    balance DOUBLE,\n    ts TIMESTAMP\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "insert into balances values ('1', 'USD', 600.5, '2020-04-21T16:03:43.504432Z')"
  },
  {
    "query": "insert into balances values ('2', 'USD', 950, '2020-04-21T16:08:34.404665Z')"
  },
  {
    "query": "insert into balances values ('2', 'EUR', 780.2, '2020-04-21T16:11:22.704665Z')"
  },
  {
    "query": "insert into balances values ('1', 'USD', 1500, '2020-04-21T16:11:32.904234Z')"
  },
  {
    "query": "insert into balances values ('1', 'EUR', 650.5, '2020-04-22T16:11:32.904234Z')"
  },
  {
    "query": "insert into balances values ('2', 'USD', 900.75, '2020-04-22T16:12:43.504432Z')"
  },
  {
    "query": "insert into balances values ('2', 'EUR', 880.2, '2020-04-22T16:18:34.404665Z')"
  },
  {
    "query": "insert into balances values ('1', 'USD', 330.5, '2020-04-22T16:20:14.404997Z')"
  },
  {
    "query": "SELECT * FROM balances\nLATEST ON ts PARTITION BY cust_id"
  },
  {
    "query": "SELECT cust_id, balance_ccy, balance\nFROM balances\nLATEST ON ts PARTITION BY cust_id, balance_ccy"
  },
  {
    "query": "CREATE TABLE unordered_balances (\n    cust_id SYMBOL,\n    balance_ccy SYMBOL,\n    balance DOUBLE,\n    ts TIMESTAMP\n)"
  },
  {
    "query": "insert into unordered_balances values ('2', 'USD', 950, '2020-04-21T16:08:34.404665Z')"
  },
  {
    "query": "insert into unordered_balances values ('1', 'USD', 330.5, '2020-04-22T16:20:14.404997Z')"
  },
  {
    "query": "insert into unordered_balances values ('2', 'USD', 900.75, '2020-04-22T16:12:43.504432Z')"
  },
  {
    "query": "insert into unordered_balances values ('1', 'USD', 1500, '2020-04-21T16:11:32.904234Z')"
  },
  {
    "query": "insert into unordered_balances values ('1', 'USD', 600.5, '2020-04-21T16:03:43.504432Z')"
  },
  {
    "query": "insert into unordered_balances values ('1', 'EUR', 650.5, '2020-04-22T16:11:32.904234Z')"
  },
  {
    "query": "insert into unordered_balances values ('2', 'EUR', 880.2, '2020-04-22T16:18:34.404665Z')"
  },
  {
    "query": "insert into unordered_balances values ('2', 'EUR', 780.2, '2020-04-21T16:11:22.704665Z')"
  },
  {
    "query": "(SELECT * FROM unordered_balances)\nLATEST ON ts PARTITION BY cust_id",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM balances\nWHERE balance > 800\nLATEST ON ts PARTITION BY cust_id"
  },
  {
    "query": "(SELECT * FROM balances LATEST ON ts PARTITION BY cust_id) --note the brackets\nWHERE balance > 800",
    "skipAutocomplete": true
  },
  {
    "query": "(balances WHERE ts in '2020-04-21' LATEST ON ts PARTITION BY cust_id)\nWHERE balance > 800",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE TABLE tango (id LONG)"
  },
  {
    "query": "INSERT INTO tango VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10)"
  },
  {
    "query": "SELECT * FROM tango LIMIT 5"
  },
  {
    "query": "SELECT * FROM tango LIMIT -5"
  },
  {
    "query": "SELECT * FROM tango LIMIT 2, 5"
  },
  {
    "query": "SELECT * FROM tango LIMIT -5, -3"
  },
  {
    "query": "SELECT * FROM tango LIMIT 2, -1"
  },
  {
    "query": "SELECT * FROM tango LIMIT 5, 2"
  },
  {
    "query": "SELECT * FROM tango LIMIT -3, -5"
  },
  {
    "query": "ratings ORDER BY userId",
    "skipAutocomplete": true
  },
  {
    "query": "ratings ORDER BY userId DESC",
    "skipAutocomplete": true
  },
  {
    "query": "ratings ORDER BY userId, rating DESC",
    "skipAutocomplete": true
  },
  {
    "query": "trades PIVOT (\n    avg(price)\n    FOR symbol IN ('BTC-USD', 'ETH-USD')\n    GROUP BY side\n)\nORDER BY side      -- outside PIVOT parentheses\nLIMIT 10",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT\n    avg(CASE WHEN symbol = 'BTC-USD' THEN price END) AS \"BTC-USD\",\n    avg(CASE WHEN symbol = 'ETH-USD' THEN price END) AS \"ETH-USD\"\nFROM trades"
  },
  {
    "query": "trades PIVOT (\n    avg(price)\n    FOR symbol IN ('BTC-USD', 'ETH-USD')\n)",
    "skipAutocomplete": true
  },
  {
    "query": "trades PIVOT (\n    avg(price)\n    FOR symbol IN ('BTC-USD', 'ETH-USD')\n        side IN ('buy', 'sell')\n)",
    "skipAutocomplete": true
  },
  {
    "query": "trades PIVOT (\n    avg(price)\n    FOR symbol IN ('BTC-USD', 'ETH-USD')\n    GROUP BY side\n) ORDER BY side",
    "skipAutocomplete": true
  },
  {
    "query": "trades PIVOT (\n    avg(price)\n    FOR symbol IN (SELECT DISTINCT symbol FROM trades ORDER BY symbol)\n    GROUP BY side\n)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT * FROM recent_trades\nPIVOT (\n    avg(price)\n    FOR symbol IN (SELECT DISTINCT symbol FROM recent_trades)\n    GROUP BY side\n)"
  },
  {
    "query": "trades PIVOT (\n    avg(price), sum(price)\n    FOR symbol IN ('BTC-USD', 'ETH-USD')\n)",
    "skipAutocomplete": true
  },
  {
    "query": "-- This would fail if combinations  aggregates > 5000\ntrades PIVOT (\n    avg(price)\n    FOR symbol IN (SELECT DISTINCT symbol FROM trades)  -- many symbols\n        side IN ('buy', 'sell')                         --  2\n)",
    "skipAutocomplete": true
  },
  {
    "query": "REFRESH MATERIALIZED VIEW trades_hourly FULL"
  },
  {
    "query": "REFRESH MATERIALIZED VIEW trades_hourly INCREMENTAL"
  },
  {
    "query": "REFRESH MATERIALIZED VIEW trades_hourly\n  RANGE FROM '2025-05-01T00:00:00Z' TO '2025-05-02T00:00:00Z'"
  },
  {
    "query": "SELECT view_name, view_status, invalidation_reason\nFROM materialized_views()\nWHERE view_name = 'trades_hourly'"
  },
  {
    "query": "-- Rebuild the view\nREFRESH MATERIALIZED VIEW trades_hourly FULL"
  },
  {
    "query": "-- Verify it's valid again\nSELECT view_name, view_status\nFROM materialized_views()\nWHERE view_name = 'trades_hourly';",
    "skipAutocomplete": true
  },
  {
    "query": "CREATE MATERIALIZED VIEW daily_summary\nREFRESH MANUAL AS\nSELECT timestamp, symbol, sum(amount) AS volume\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "-- Refresh when ready (e.g., after batch load completes)\nREFRESH MATERIALIZED VIEW daily_summary INCREMENTAL"
  },
  {
    "query": "-- Refresh just that day\nREFRESH MATERIALIZED VIEW trades_hourly\n  RANGE FROM '2025-05-01T00:00:00Z' TO '2025-05-02T00:00:00Z';",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT\n  view_name,\n  view_status,\n  refresh_base_table_txn,\n  base_table_txn,\n  last_refresh_start_timestamp,\n  last_refresh_finish_timestamp\nFROM materialized_views()\nWHERE view_name = 'trades_hourly'"
  },
  {
    "query": "REINDEX TABLE trades LOCK EXCLUSIVE"
  },
  {
    "query": "REINDEX TABLE trades COLUMN instruments LOCK EXCLUSIVE"
  },
  {
    "query": "REINDEX TABLE trades COLUMN instruments PARTITION '2021-12-17' LOCK EXCLUSIVE"
  },
  {
    "query": "RENAME TABLE 'test.csv' TO 'myTable'"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1h"
  },
  {
    "query": "SELECT timestamp as ts, count()\nFROM trades\nSAMPLE BY 1d FROM '2009-01-01' TO '2009-01-10' FILL(NULL)"
  },
  {
    "query": "SELECT timestamp as ts, count()\nFROM trades\nWHERE timestamp >= '2009-01-01'\n  AND timestamp <  '2009-01-10'\nSAMPLE BY 1d FROM '2009-01-01' TO '2009-01-10' FILL(NULL)"
  },
  {
    "query": "SELECT ts, max(price) max\nFROM prices\nSAMPLE BY 1h"
  },
  {
    "query": "SELECT ts, max(price) max\nFROM prices\nSAMPLE BY 1h FILL(PREV)"
  },
  {
    "query": "SELECT ts, max(price) max\nFROM prices\nSAMPLE BY 1h FILL(LINEAR)"
  },
  {
    "query": "SELECT ts, max(price) max\nFROM prices\nSAMPLE BY 1h FILL(100.5)"
  },
  {
    "query": "SELECT ts, max(price) max\nFROM prices\nSAMPLE BY 1h FILL(NULL)"
  },
  {
    "query": "SELECT min(price), max(price), avg(price), ts\nFROM prices\nSAMPLE BY 1h\nFILL(NULL, 10, PREV)"
  },
  {
    "query": "CREATE TABLE trades (\n  ts TIMESTAMP,\n  price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY WAL"
  },
  {
    "query": "INSERT INTO trades (ts, price) VALUES\n  ('2021-05-31T23:10:00.000000Z', 100.5),\n  ('2021-06-01T01:10:00.000000Z', 101.2),\n  ('2021-06-01T07:20:00.000000Z', 100.8),\n  ('2021-06-01T13:20:00.000000Z', 101.0),\n  ('2021-06-01T19:20:00.000000Z', 102.1),\n  ('2021-06-02T01:10:00.000000Z', 101.5),\n  ('2021-06-02T07:20:00.000000Z', 100.9)"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d\nALIGN TO FIRST OBSERVATION"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d\nALIGN TO CALENDAR"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d\nALIGN TO CALENDAR TIME ZONE 'Europe/Berlin'"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d\nALIGN TO CALENDAR TIME ZONE 'Europe/Berlin' WITH OFFSET '00:45'"
  },
  {
    "query": "SELECT to_timezone(ts, 'PST') ts, count\nFROM (\n  SELECT ts, count()\n  FROM trades\n  SAMPLE BY 2h\n  ALIGN TO CALENDAR TIME ZONE 'PST'\n)"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1h\nALIGN TO CALENDAR TIME ZONE 'Europe/London'"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1d\nALIGN TO CALENDAR WITH OFFSET '02:00'"
  },
  {
    "query": "SELECT ts, count()\nFROM trades\nSAMPLE BY 1h\nALIGN TO CALENDAR TIME ZONE 'Europe/London' WITH OFFSET '02:00'"
  },
  {
    "query": "SELECT ts, sum(quantity*price)\nFROM trades\nSAMPLE BY 30m"
  },
  {
    "query": "SELECT ts, avg(quantity*price)\nFROM trades\nSAMPLE BY 1d"
  },
  {
    "query": "SELECT ts, avg(quantity*price)\nFROM trades\nSAMPLE BY 1d\nALIGN TO CALENDAR"
  },
  {
    "query": "CREATE MATERIALIZED VIEW hourly_metrics AS\nSELECT \n    timestamp_floor('h', ts) as hour,\n    symbol,\n    avg(price) as avg_price,\n    sum(volume) as total_volume\nFROM trades\nSAMPLE BY 1h"
  },
  {
    "query": "SELECT timestamp, symbol, side FROM trades"
  },
  {
    "query": "SELECT timestamp, symbol,\n    price AS rate,\n    amount quantity\nFROM trades"
  },
  {
    "query": "SELECT timestamp, symbol,\n    price * 0.25 AS price25pct,\n    amount > 10 AS over10\nFROM trades"
  },
  {
    "query": "SELECT\n    (true AND false) AS this_will_return_false,\n    (true OR false) AS this_will_return_true"
  },
  {
    "query": "SELECT\n    NOT (true AND false) AS this_will_return_true"
  },
  {
    "query": "SELECT\n    (1 ^ 1) AS will_return_0,\n    (1 ^ 20) AS will_return_21,\n    (true::int ^ false::long)::boolean AS will_return_true,\n    (true::int ^ true::long)::boolean AS will_return_false"
  },
  {
    "query": "SELECT symbol, avg(price), count()\nFROM trades"
  },
  {
    "query": "SELECT symbol, avg(price), count()\nFROM trades\nGROUP BY symbol"
  },
  {
    "query": "SELECT symbol, avg(price), count()\nFROM trades\nGROUP BY 1"
  },
  {
    "query": "SELECT symbol, (min(price) + max(price))/2 mid, count() count\nFROM trades"
  },
  {
    "query": "SHOW COLUMNS FROM trades"
  },
  {
    "query": "SHOW CREATE TABLE trades"
  },
  {
    "query": "CREATE TABLE trades (\n\tsymbol SYMBOL CAPACITY 256 CACHE,\n\tside SYMBOL CAPACITY 256 CACHE,\n\tprice DOUBLE,\n\tamount DOUBLE,\n\ttimestamp TIMESTAMP\n) timestamp(timestamp) PARTITION BY DAY WAL\nWITH maxUncommittedRows=500000, o3MaxLag=600000000us"
  },
  {
    "query": "CREATE TABLE trades (\n\tsymbol SYMBOL CAPACITY 256 CACHE,\n\tside SYMBOL CAPACITY 256 CACHE,\n\tprice DOUBLE,\n\tamount DOUBLE,\n\ttimestamp TIMESTAMP\n) timestamp(timestamp) PARTITION BY DAY WAL\nWITH maxUncommittedRows=500000, o3MaxLag=600000000us\nOWNED BY 'admin'"
  },
  {
    "query": "SHOW PARTITIONS FROM my_table"
  },
  {
    "query": "SHOW PARAMETERS"
  },
  {
    "query": "-- This query will return all parameters where the value contains 'tmp', ignoring upper/lower case\n(SHOW PARAMETERS) WHERE value ILIKE '%tmp%'",
    "skipAutocomplete": true
  },
  {
    "query": "-- This query will return all parameters where the property_path is not 'cairo.root' or 'cairo.sql.backup.root', ordered by the first column\n(SHOW PARAMETERS) WHERE property_path NOT IN ('cairo.root', 'cairo.sql.backup.root') ORDER BY 1",
    "skipAutocomplete": true
  },
  {
    "query": "-- This query will return all parameters where the value_source is 'env'\n(SHOW PARAMETERS) WHERE value_source = 'env'",
    "skipAutocomplete": true
  },
  {
    "query": "-- Show all the parameters that have been modified from their defaults, via conf file or env variable\n(SHOW PARAMETERS) WHERE  value_source <> 'default'",
    "skipAutocomplete": true
  },
  {
    "query": "SHOW USER"
  },
  {
    "query": "SHOW SERVICE ACCOUNT"
  },
  {
    "query": "SHOW SERVICE ACCOUNT ilp_ingestion"
  },
  {
    "query": "SHOW SERVICE ACCOUNTS admin_group"
  },
  {
    "query": "SHOW PERMISSIONS"
  },
  {
    "query": "SHOW PERMISSIONS admin"
  },
  {
    "query": "SHOW PERMISSIONS admin_group"
  },
  {
    "query": "SHOW PERMISSIONS ilp_ingestion"
  },
  {
    "query": "SHOW SERVER_VERSION"
  },
  {
    "query": "TRUNCATE TABLE trades"
  },
  {
    "query": "TRUNCATE TABLE IF EXISTS trades_non_existent"
  },
  {
    "query": "select '1'::varchar as col from long_sequence(1)\n    union all\n    select '127.0.0.1'::ipv4 from long_sequence(1)"
  },
  {
    "query": "sensor_1 UNION sensor_2",
    "skipAutocomplete": true
  },
  {
    "query": "sensor_1\nUNION\nsensor_2 WHERE ID > 10",
    "skipAutocomplete": true
  },
  {
    "query": "sensor_1 UNION ALL sensor_2",
    "skipAutocomplete": true
  },
  {
    "query": "sensor_1 EXCEPT sensor_2",
    "skipAutocomplete": true
  },
  {
    "query": "sensor_1 EXCEPT ALL sensor_2",
    "skipAutocomplete": true
  },
  {
    "query": "sensor_1 INTERSECT sensor_2",
    "skipAutocomplete": true
  },
  {
    "query": "query_1 UNION query_2 EXCEPT query_3",
    "skipAutocomplete": true
  },
  {
    "query": "(query_1 UNION query_2) EXCEPT query_3",
    "skipAutocomplete": true
  },
  {
    "query": "query_1 UNION query_2 INTERSECT query_3",
    "skipAutocomplete": true
  },
  {
    "query": "(query_1 UNION query_2) INTERSECT query_3",
    "skipAutocomplete": true
  },
  {
    "query": "query_1 UNION query_2\nLIMIT 3",
    "skipAutocomplete": true
  },
  {
    "query": "(query_1 UNION query_2)\nLIMIT 3",
    "skipAutocomplete": true
  },
  {
    "query": "query_1 UNION query_2\nWHERE value = 1",
    "skipAutocomplete": true
  },
  {
    "query": "query_1 UNION (query_2 WHERE value = 1)",
    "skipAutocomplete": true
  },
  {
    "query": "SELECT alias_1 FROM table_1\nUNION\nSELECT alias_2 FROM table_2"
  },
  {
    "query": "UPDATE trades SET price = 125.34 WHERE symbol = 'AAPL'"
  },
  {
    "query": "UPDATE book SET mid = (bid + ask)/2 WHERE symbol = 'AAPL'"
  },
  {
    "query": "UPDATE spreads s SET spread = p.ask - p.bid FROM prices p WHERE s.symbol = p.symbol"
  },
  {
    "query": "WITH up AS (\n    SELECT p.ask - p.bid AS spread, p.timestamp\n    FROM prices p\n    JOIN instruments i ON p.symbol = i.symbol\n    WHERE i.type = 'BOND'\n)\nUPDATE spreads s\nSET spread = up.spread\nFROM up\nWHERE s.timestamp = up.timestamp",
    "skipAutocomplete": true
  },
  {
    "query": "WITH up AS (\n    SELECT symbol, spread, ts\n    FROM temp_spreads\n    WHERE timestamp between '2022-01-02' and '2022-01-03'\n)\nUPDATE spreads s\nSET spread = up.spread\nFROM up\nWHERE up.ts = s.ts AND s.symbol = up.symbol"
  },
  {
    "query": "VACUUM TABLE trades"
  },
  {
    "query": "SELECT * FROM users\nWHERE name = 'John'"
  },
  {
    "query": "SELECT * FROM users\nWHERE name != 'John'"
  },
  {
    "query": "SELECT * FROM users WHERE name ~ 'Jo'"
  },
  {
    "query": "SELECT * FROM users WHERE name !~ 'Jo'"
  },
  {
    "query": "SELECT * FROM users WHERE name in('Tim', 'Tom')"
  },
  {
    "query": "SELECT * FROM users WHERE NOT name in('Tim', 'Tom')"
  },
  {
    "query": "SELECT * FROM users WHERE age >= 23"
  },
  {
    "query": "SELECT * FROM users WHERE age = 23"
  },
  {
    "query": "SELECT * FROM users WHERE age != 23"
  },
  {
    "query": "SELECT * FROM users WHERE isActive"
  },
  {
    "query": "SELECT * FROM users WHERE NOT isActive"
  },
  {
    "query": "SELECT * FROM scores WHERE ts = '2010-01-12T00:02:26.000Z'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts = '2010-01-12T00:02:26.000000Z'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts IN '2018'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts IN '2018-05-23T12:15'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts IN '2018;1M'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts IN '2018-01;-3d'"
  },
  {
    "query": "SELECT * FROM scores WHERE ts IN '2018-01-01;1d;1y;2'"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp in '2023'"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp in '2023-12'"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp in '2023-12-20'"
  },
  {
    "query": "SELECT * FROM trades WHERE timestamp in '2023-12-20;15s'"
  },
  {
    "query": "SELECT * from trades WHERE timestamp in '2023-09-20T23:59:58;4s;-1d;7'"
  },
  {
    "query": "SELECT * FROM scores\nWHERE ts BETWEEN '2018-01-01T00:00:23.000000Z' AND '2018-01-01T00:00:23.500000Z'"
  },
  {
    "query": "SELECT * FROM scores\nWHERE ts BETWEEN to_str(now(), 'yyyy-MM-dd')\nAND dateadd('y', -1, to_str(now(), 'yyyy-MM-dd'))"
  },
  {
    "query": "SELECT *\nFROM trades\nWHERE timestamp BETWEEN '2024-04-01' AND '2024-04-03'\nLIMIT -1"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.price,\n    t.ts,\n    sum(p.price) AS window_sum\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\n    EXCLUDE PREVAILING\nORDER BY t.ts"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    avg(p.bid) AS avg_bid,\n    count() AS num_prices\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 5 seconds PRECEDING AND 5 seconds FOLLOWING\n    EXCLUDE PREVAILING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    avg(p.price) AS avg_price\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym) AND p.price < 300\n    RANGE BETWEEN 2 minutes PRECEDING AND 2 minutes FOLLOWING\n    EXCLUDE PREVAILING\nORDER BY t.ts"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    sum(p.price) AS past_sum\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 2 minutes PRECEDING AND 1 minute PRECEDING\n    EXCLUDE PREVAILING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    sum(p.price) AS future_sum\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 1 minute FOLLOWING AND 2 minutes FOLLOWING\n    EXCLUDE PREVAILING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    count() AS total_prices\nFROM trades t\nWINDOW JOIN prices p\n    RANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\n    EXCLUDE PREVAILING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    t.price,\n    sum(p.bid) AS sum_bids,\n    avg(q.ask) AS avg_asks\nFROM trades t\nWINDOW JOIN bids p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\nWINDOW JOIN asks q\n    ON (t.sym = q.sym)\n    RANGE BETWEEN 30 seconds PRECEDING AND 30 seconds FOLLOWING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    sum(p.price) AS window_sum\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\n    EXCLUDE PREVAILING"
  },
  {
    "query": "SELECT\n    t.sym,\n    t.ts,\n    sum(p.price) AS window_sum\nFROM trades t\nWINDOW JOIN prices p\n    ON (t.sym = p.sym)\n    RANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\n    EXCLUDE PREVAILING\nWHERE t.price < 450\nORDER BY t.ts"
  },
  {
    "query": "EXPLAIN SELECT t.sym, sum(p.price)\nFROM trades t\nWINDOW JOIN prices p ON (t.sym = p.sym)\nRANGE BETWEEN 1 minute PRECEDING AND 1 minute FOLLOWING\nEXCLUDE PREVAILING"
  },
  {
    "query": "-- This will NOT work:\nSELECT\n    t.counterparty,\n    count(*) AS trade_count,\n    avg(first(m.mid_price) - t.price) AS avg_slippage\nFROM trades t\nWINDOW JOIN market_data m ON (t.symbol = m.symbol)\n    RANGE BETWEEN 10 milliseconds FOLLOWING AND 10 milliseconds FOLLOWING\nGROUP BY t.counterparty"
  },
  {
    "query": "WITH trades_with_future_mid AS (\n    SELECT\n        t.counterparty,\n        t.price,\n        first(m.mid_price) AS future_mid\n    FROM trades t\n    WINDOW JOIN market_data m ON (t.symbol = m.symbol)\n        RANGE BETWEEN 10 milliseconds FOLLOWING AND 10 milliseconds FOLLOWING\n        INCLUDE PREVAILING\n    WHERE t.timestamp > dateadd('d', -1, now())\n)\nSELECT\n    counterparty,\n    count(*) AS trade_count,\n    avg(future_mid - price) AS avg_slippage\nFROM trades_with_future_mid\nGROUP BY counterparty"
  },
  {
    "query": "SELECT user_name FROM first_10_users"
  },
  {
    "query": "SELECT user_name FROM first_5_users"
  },
  {
    "query": "SELECT timestamp, trades.price > avg_price.average above_average\nFROM trades CROSS JOIN avg_price"
  },
  {
    "query": "WITH up AS (\n    SELECT symbol, spread, ts\n    FROM temp_spreads\n    WHERE timestamp between '2022-01-02' and '2022-01-03'\n)\nINSERT INTO spreads\nSELECT * FROM up"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    side SYMBOL,\n    price DOUBLE,\n    quantity DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE market_data (\n    ts TIMESTAMP,        -- Will be the designated timestamp\n    symbol SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,       -- Stock ticker: AAPL, GOOGL, etc.\n    side SYMBOL,         -- BUY or SELL\n    price DOUBLE,\n    quantity DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE trades (\n    ts TIMESTAMP,              -- Microsecond precision (recommended)\n    exchange_ts TIMESTAMP_NS,  -- Nanosecond precision (if needed)\n    symbol SYMBOL,\n    price DOUBLE\n) TIMESTAMP(ts)"
  },
  {
    "query": "CREATE TABLE quotes (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    bid DOUBLE,\n    ask DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY\nDEDUP UPSERT KEYS(timestamp, symbol)"
  },
  {
    "query": "CREATE TABLE tick_data (\n    timestamp TIMESTAMP,\n    symbol SYMBOL,\n    price DOUBLE,\n    size LONG\n) TIMESTAMP(timestamp) PARTITION BY DAY TTL 90 DAYS"
  },
  {
    "query": "CREATE MATERIALIZED VIEW ohlc_1h AS\n  SELECT\n    timestamp,\n    symbol,\n    first(price) as open,\n    max(price) as high,\n    min(price) as low,\n    last(price) as close,\n    sum(quantity) as volume\n  FROM trades\n  SAMPLE BY 1h"
  },
  {
    "query": "CREATE VIEW recent_trades AS (\n  SELECT * FROM trades\n  WHERE timestamp > dateadd('d', -7, now())\n)"
  },
  {
    "query": "CREATE VIEW trades_above AS (\n  DECLARE OVERRIDABLE @min_price := 100\n  SELECT * FROM trades WHERE price >= @min_price\n)"
  },
  {
    "query": "-- Override at query time\nDECLARE @min_price := 500 SELECT * FROM trades_above"
  },
  {
    "query": "CREATE TABLE trades (\n    ts TIMESTAMP,\n    price DOUBLE\n)"
  },
  {
    "query": "CREATE TABLE trades (\n    ts TIMESTAMP,\n    price DOUBLE\n) TIMESTAMP(ts)"
  },
  {
    "query": "-- 2. Copy data\nINSERT INTO trades_new SELECT * FROM trades"
  },
  {
    "query": "CREATE TABLE metrics (\n    timestamp TIMESTAMP,\n    name SYMBOL,\n    value DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY\nDEDUP UPSERT KEYS(timestamp, name)"
  },
  {
    "query": "CREATE TABLE metrics (\n    timestamp TIMESTAMP,\n    name SYMBOL,\n    region SYMBOL,\n    value DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE TABLE metrics (\n    timestamp TIMESTAMP,\n    name VARCHAR,\n    value DOUBLE\n)"
  },
  {
    "query": "CREATE TABLE metrics (\n    timestamp TIMESTAMP,\n    name SYMBOL,          -- Use SYMBOL for repeated strings\n    value DOUBLE\n) TIMESTAMP(timestamp) PARTITION BY DAY"
  },
  {
    "query": "CREATE GROUP groupName WITH EXTERNAL ALIAS 'CN=TestGroup1,OU=DC Users,DC=ad,DC=quest,DC=dev'"
  },
  {
    "query": "ALTER GROUP groupName WITH EXTERNAL ALIAS 'CN=TestGroup1,OU=DC Users,DC=ad,DC=quest,DC=dev'"
  },
  {
    "query": "ALTER GROUP groupName DROP EXTERNAL ALIAS 'CN=TestGroup1,OU=DC Users,DC=ad,DC=quest,DC=dev'"
  },
  {
    "query": "CREATE GROUP extUsers WITH EXTERNAL ALIAS '87654321-1234-1234-1234-123456789abc'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO groupName"
  },
  {
    "query": "GRANT SELECT ON table1, table2 to groupName"
  },
  {
    "query": "CREATE USER analyst WITH PASSWORD 'secure_password_here'"
  },
  {
    "query": "-- 2. Grant endpoint access (required to connect)\nGRANT PGWIRE, HTTP TO analyst"
  },
  {
    "query": "-- 3. Grant read access to specific tables\nGRANT SELECT ON trades, prices TO analyst"
  },
  {
    "query": "SHOW PERMISSIONS analyst"
  },
  {
    "query": "-- User can connect via PostgreSQL protocol only (not web console)\nGRANT PGWIRE TO analyst"
  },
  {
    "query": "-- Service can only ingest via ILP, cannot query\nGRANT ILP TO ingest_service"
  },
  {
    "query": "-- Full interactive access\nGRANT HTTP, PGWIRE TO developer"
  },
  {
    "query": "-- User can only see timestamp and price, not quantity or trader_id\nGRANT SELECT ON trades(ts, price) TO analyst"
  },
  {
    "query": "CREATE VIEW aapl_trades AS (\n  SELECT * FROM trades WHERE symbol = 'AAPL'\n)"
  },
  {
    "query": "-- Grant access to the view, not the base table\nGRANT SELECT ON aapl_trades TO aapl_analyst"
  },
  {
    "query": "CREATE USER analyst WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO analyst"
  },
  {
    "query": "GRANT SELECT ON ALL TABLES TO analyst"
  },
  {
    "query": "CREATE SERVICE ACCOUNT ingest_app WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT ILP TO ingest_app"
  },
  {
    "query": "-- InfluxDB Line Protocol access\nGRANT INSERT ON sensor_data TO ingest_app"
  },
  {
    "query": "CREATE GROUP trading_team"
  },
  {
    "query": "-- Grant permissions to the group\nGRANT HTTP, PGWIRE TO trading_team"
  },
  {
    "query": "GRANT SELECT ON trades, positions TO trading_team"
  },
  {
    "query": "GRANT INSERT ON trades TO trading_team"
  },
  {
    "query": "CREATE USER alice WITH PASSWORD 'pwd1'"
  },
  {
    "query": "CREATE USER bob WITH PASSWORD 'pwd2'"
  },
  {
    "query": "ADD USER alice TO trading_team"
  },
  {
    "query": "ADD USER bob TO trading_team"
  },
  {
    "query": "CREATE USER auditor WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO auditor"
  },
  {
    "query": "-- Grant access to non-sensitive columns only\nGRANT SELECT ON employees(id, name, department, hire_date) TO auditor"
  },
  {
    "query": "CREATE TABLE sales (ts TIMESTAMP, region SYMBOL, amount DOUBLE) TIMESTAMP(ts)"
  },
  {
    "query": "CREATE VIEW sales_emea AS (SELECT * FROM sales WHERE region = 'EMEA')"
  },
  {
    "query": "CREATE VIEW sales_apac AS (SELECT * FROM sales WHERE region = 'APAC')"
  },
  {
    "query": "CREATE USER emea_manager WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO emea_manager"
  },
  {
    "query": "GRANT SELECT ON sales_emea TO emea_manager"
  },
  {
    "query": "CREATE USER apac_manager WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT HTTP, PGWIRE TO apac_manager"
  },
  {
    "query": "GRANT SELECT ON sales_apac TO apac_manager"
  },
  {
    "query": "CREATE USER dba WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT DATABASE ADMIN TO dba"
  },
  {
    "query": "CREATE USER human_user WITH PASSWORD 'pwd'"
  },
  {
    "query": "CREATE SERVICE ACCOUNT app_account WITH PASSWORD 'pwd'"
  },
  {
    "query": "CREATE SERVICE ACCOUNT trading_app WITH PASSWORD 'pwd'"
  },
  {
    "query": "GRANT ILP TO trading_app"
  },
  {
    "query": "GRANT INSERT ON trades TO trading_app"
  },
  {
    "query": "GRANT SELECT ON positions TO trading_app"
  },
  {
    "query": "-- Developer can assume the service account to test its access\nGRANT ASSUME SERVICE ACCOUNT trading_app TO developer"
  },
  {
    "query": "-- Developer switches to service account context\nASSUME SERVICE ACCOUNT trading_app"
  },
  {
    "query": "GRANT SELECT ON ALL TABLES TO analysts"
  },
  {
    "query": "-- All users added to this group can read all tables\nADD USER alice TO analysts"
  },
  {
    "query": "ADD USER bob TO analysts"
  },
  {
    "query": "-- Add JWK token for ILP access\nALTER USER sensor_writer CREATE TOKEN TYPE JWK"
  },
  {
    "query": "-- Add REST API token (with 30-day expiry)\nALTER USER api_user CREATE TOKEN TYPE REST WITH TTL '30d'"
  },
  {
    "query": "-- Typical setup for an interactive user\nGRANT HTTP, PGWIRE TO analyst"
  },
  {
    "query": "-- Typical setup for an ingestion service\nGRANT ILP TO ingest_service"
  },
  {
    "query": "GRANT SELECT ON trades TO team_lead WITH GRANT OPTION"
  },
  {
    "query": "GRANT INSERT ON future_table TO app"
  },
  {
    "query": "-- Grant ability to assume\nGRANT ASSUME SERVICE ACCOUNT ingest_app TO developer"
  },
  {
    "query": "-- Developer can now switch context\nASSUME SERVICE ACCOUNT ingest_app"
  },
  {
    "query": "CREATE USER username WITH PASSWORD 'pwd'"
  },
  {
    "query": "DROP USER username"
  },
  {
    "query": "CREATE SERVICE ACCOUNT appname WITH PASSWORD 'pwd'"
  },
  {
    "query": "DROP SERVICE ACCOUNT appname"
  },
  {
    "query": "CREATE GROUP groupname"
  },
  {
    "query": "DROP GROUP groupname"
  },
  {
    "query": "ADD USER username TO group1, group2"
  },
  {
    "query": "REMOVE USER username FROM group1"
  },
  {
    "query": "-- Change password\nALTER USER username WITH PASSWORD 'new_pwd'"
  },
  {
    "query": "-- Remove password (disables password auth)\nALTER USER username WITH NO PASSWORD"
  },
  {
    "query": "-- Create tokens\nALTER USER username CREATE TOKEN TYPE JWK"
  },
  {
    "query": "ALTER USER username CREATE TOKEN TYPE REST WITH TTL '30d'"
  },
  {
    "query": "ALTER USER username CREATE TOKEN TYPE REST WITH TTL '1d' REFRESH"
  },
  {
    "query": "-- Remove tokens\nALTER USER username DROP TOKEN TYPE JWK"
  },
  {
    "query": "ALTER USER username DROP TOKEN TYPE REST"
  },
  {
    "query": "-- Drops all REST tokens\nALTER USER username DROP TOKEN TYPE REST 'token_value_here'"
  },
  {
    "query": "-- List all users\nSHOW SERVICE ACCOUNTS"
  },
  {
    "query": "-- List all service accounts\nSHOW GROUPS"
  },
  {
    "query": "-- List all groups\nSHOW GROUPS username"
  },
  {
    "query": "-- List groups for a user\nSHOW USER username"
  },
  {
    "query": "-- Show auth methods for user\nSHOW PERMISSIONS username"
  },
  {
    "query": "SELECT * FROM all_permissions()"
  },
  {
    "query": "ALTER TABLE my_table ALTER COLUMN str_col TYPE VARCHAR"
  },
  {
    "query": "ALTER TABLE my_table ALTER COLUMN var_col TYPE SYMBOL CAPACITY 4096"
  },
  {
    "query": "SELECT timestamp, col1\nFROM 'table1'\nWHERE timestamp IN '2000-01-01T09:15;405m;1d;365'"
  },
  {
    "query": "SELECT * FROM diagnostics WHERE timestamp = '2016-01-01T00:00:00.000000Z' AND driver='Andy' AND name='truck_150'"
  },
  {
    "query": "SELECT\n  timestamp,\n  device_version,\n  driver,\n  fleet,\n  model,\n  name,\n  max(current_load) AS current_load,\n  max(fuel_capacity) AS fuel_capacity,\n  max(fuel_state) AS fuel_state,\n  max(load_capacity) AS load_capacity,\n  max(nominal_fuel_consumption) AS nominal_fuel_consumption,\n  max(status) AS status\nFROM\n  diagnostics"
  },
  {
    "query": "CREATE TABLE market_data (\n  timestamp TIMESTAMP,\n  symbol SYMBOL,\n  bids DOUBLE[][],\n  asks DOUBLE[][]\n) TIMESTAMP(timestamp) PARTITION BY HOUR"
  },
  {
    "query": "SELECT timestamp, spread(bids[1][1], asks[1][1]) spread\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', ARRAY[ [9.3, 9.2], [0, 0] ], ARRAY[ [10.1, 10.2], [0, 0] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', ARRAY[ [9.7, 9.4], [0, 0] ], ARRAY[ [10.3, 10.5], [0, 0] ])"
  },
  {
    "query": "SELECT timestamp, array_sum(@relevant_volume_levels) total_volume\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', NULL, ARRAY[ [10.00, 10.02, 10.04, 10.10, 10.12, 10.14], [10.0, 15, 13, 12, 18, 20] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', NULL, ARRAY[ [20.00, 20.02, 20.04, 20.10, 20.12, 20.14], [1.0, 5, 3, 2, 8, 10] ])"
  },
  {
    "query": "SELECT timestamp, array_sum(@relevant_volumes) volume\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', NULL, ARRAY[ [10.0, 10.02, 10.04, 10.10, 10.12, 10.14], [10.0, 15, 13, 12, 18, 20] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', NULL, ARRAY[ [10.0, 10.10, 10.12, 10.14, 10.16, 10.18], [1.0, 5, 3, 2, 8, 10] ])"
  },
  {
    "query": "DECLARE\n  @prices := asks[1],\n  @volumes := asks[2],\n  @target_volume := 30.0\nSELECT\n  timestamp,\n  array_cum_sum(@volumes) cum_volumes,\n  insertion_point(cum_volumes, @target_volume, true) target_level,\n  @prices[target_level] price\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', NULL, ARRAY[ [10.0, 10.02, 10.04, 10.10, 10.12, 10.14], [10.0, 15, 13, 12, 18, 20] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', NULL, ARRAY[ [10.0, 10.02, 10.04, 10.10, 10.12, 10.14], [10.0,  5,  3, 12, 18, 20] ])"
  },
  {
    "query": "SELECT\n  timestamp, bids[2, 1] / asks[2, 1] imbalance\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', ARRAY[ [0.0,0], [20.0, 25] ], ARRAY[ [0.0,0], [10.0, 15] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', ARRAY[ [0.0,0], [14.0, 45] ], ARRAY[ [0.0,0], [15.0,  2] ])"
  },
  {
    "query": "DECLARE\n  @bid_volumes := bids[2],\n  @ask_volumes := asks[2]\nSELECT\n  timestamp,\n  array_sum(@bid_volumes[1:4]) bid_vol,\n  array_sum(@ask_volumes[1:4]) ask_vol,\n  bid_vol / ask_vol ratio\nFROM market_data WHERE symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', ARRAY[ [0.0,0,0,0], [20.0, 25, 23, 22] ], ARRAY[ [0.0,0,0,0], [10.0, 15, 13, 12] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', ARRAY[ [0.0,0,0,0], [14.0, 45, 22,  5] ], ARRAY[ [0.0,0,0,0], [15.0,  2, 20, 23] ])"
  },
  {
    "query": "SELECT * FROM (\n  SELECT\n    timestamp,\n    array_avg(@volumes[1:3]) top,\n    array_avg(@volumes[3:6]) deep\n  FROM market_data\n  WHERE timestamp > dateadd('m',-30,now()) )\nWHERE top > @dropoff_ratio * deep"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', NULL, ARRAY[ [0.0,0,0,0,0,0], [20.0, 15, 13, 12, 18, 20] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', NULL, ARRAY[ [0.0,0,0,0,0,0], [20.0, 25,  3,  7,  5,  2] ])"
  },
  {
    "query": "SELECT * FROM (\n  SELECT\n    timestamp,\n    lag(@top_bid_volume) OVER () prev_bid_vol,\n    @top_bid_volume curr_bid_vol,\n    lag(@top_ask_volume) OVER () prev_ask_vol,\n    @top_ask_volume curr_ask_vol\n  FROM market_data WHERE timestamp > dateadd('h',-1,now()) AND symbol='EURUSD' )\nWHERE prev_bid_vol > curr_bid_vol * @drop_ratio OR prev_ask_vol > curr_ask_vol * @drop_ratio\nLIMIT 10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', ARRAY[ [0.0], [10.0] ], ARRAY[ [0.0], [10.0] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', ARRAY[ [0.0], [ 9.0] ], ARRAY[ [0.0], [ 9.0] ]),\n  ('2025-07-01T12:00:02Z', 'EURUSD', ARRAY[ [0.0], [ 8.0] ], ARRAY[ [0.0], [ 4.0] ]),\n  ('2025-07-01T12:00:03Z', 'EURUSD', ARRAY[ [0.0], [ 4.0] ], ARRAY[ [0.0], [ 4.0] ])"
  },
  {
    "query": "DECLARE\n  @bid_prices := bids[1],\n  @bid_volumes := bids[2],\n  @ask_prices := asks[1],\n  @ask_volumes := asks[2],\n  @best_bid_price := bids[1, 1],\n  @best_ask_price := asks[1, 1]\nSELECT\n  timestamp,\n  round((@best_bid_price + @best_ask_price) / 2, 2) mid_price,\n  (mid_price - @bid_prices) * @bid_volumes weighted_bid_pressure,\n  (@ask_prices - mid_price) * @ask_volumes weighted_ask_pressure\nFROM market_data WHERE timestamp IN today() AND symbol='EURUSD'\nLIMIT -10"
  },
  {
    "query": "INSERT INTO market_data VALUES\n  ('2025-07-01T12:00:00Z', 'EURUSD', ARRAY[ [5.0, 5.1], [10.0, 20] ], ARRAY[ [6.0, 6.1], [15.0, 25] ]),\n  ('2025-07-01T12:00:01Z', 'EURUSD', ARRAY[ [5.1, 5.2], [20.0, 25] ], ARRAY[ [6.2, 6.4], [20.0,  9] ])"
  }
]
